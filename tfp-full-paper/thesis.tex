\documentclass[]{llncs}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments

% lncs 
\usepackage{makeidx}
%\institute{University of Groningen, The Netherlands, \\ \texttt{}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Folkert de Vries \& Jorge A. Pérez},
            pdftitle={Reversible Session-Based Concurrency in Haskell},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{6pt plus 2pt minus 1pt}
%\setlength{\emergencystretch}{3em}  % prevent overfull lines
%\setcounter{secnumdepth}{5}

%\date{}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[toc,page]{appendix}
\newcommand{\hideFromPandoc}[1]{#1}
\hideFromPandoc{ \let\Begin\begin \let\End\end }
\input{macrosCR}

\begin{document}

\title{Reversible Session-Based Concurrency in Haskell}

\author{Folkert de Vries \and
Jorge A. P\'{e}rez%\orcidID{0000-0002-1452-6180}}
}
%
\authorrunning{F.\ de Vries and J.\ A.\ P\'{e}rez}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Groningen, The Netherlands}
\maketitle



\begin{abstract}
Under a reversible semantics, computation steps can be undone. For
message-passing, concurrent programs, reversing computation steps is a
challenging and delicate task; one typically aims at formal semantics
which are \emph{causally-consistent}. Prior work has addressed this
challenge in the context of a process model of multiparty protocols
(choreographies) following a so-called \emph{monitors-as-memories}
approach. In this paper, we describe our efforts aimed at implementing
this operational semantics in Haskell. We provide an encoding based on
the formal definition of prior work's three core concepts: a process
calculus, multiparty session types and a reversible semantics.
Additionally, we provide an implementation of the forward and backward
transition functions, which make it possible to run and typecheck
programs, and finally reflect on uses of the implementation of these
semantics. 
%\pagebreak
\end{abstract}

% lncs keyword extension 
\keywords{Reversible computation \and Message-passing concurrency \and Session
Types \and Haskell.}



%{
%\hypersetup{linkcolor=black}
%\setcounter{tocdepth}{3}
%\tableofcontents
%}

\section{Introduction}
This paper describes a Haskell implementation of 
a \emph{reversible semantics} for message-passing concurrent programs. 
Our implementation is framed within a prolific line of research, which aims at  
establishing  semantic foundations for reversible computing in a 
concurrent setting (see, e.g., the survey~\cite{DBLP:journals/eatcs/Lanese14}).
Our key interest is the interplay of reversibility and message-passing concurrency, which is typically governed by
\emph{protocols} among possibly distributed partners.
A central observation here is that those protocols may inform the implementation of a reversible semantics.

In a language with a reversible semantics, computation steps can be undone.
Thus, a program can perform standard \emph{forward} steps, but also \emph{backward} steps.
Reversing a sequential program is not hard: it suffices to record enough information about  forward steps in case we wish to return to a prior state using a backward step. Reversing a concurrent program is  more difficult: since  control may simultaneously reside in more than one point, we require carefully designed \emph{memories} that not only record information about the steps performed in each thread, but also about the \emph{causal dependencies} between steps from different threads.
This motivates the definition of reversible semantics which are \emph{causally consistent}, i.e., that ensure that backward steps lead to states that could been have reached by performing forward steps only~\cite{DBLP:journals/eatcs/Lanese14}. Hence, a causally consistent  semantics never leads to states that are not reachable through forward steps. 

Causal consistency is an important correctness criterion in the definition of reversible programming languages. The quest for causally consistent reversible semantics for (message-passing) concurrency has led to a number of valuable proposals (cf.~\cite{DBLP:conf/ppdp/MezzinaP17} and references therein). One common shortcoming in several prior works is that the memories used are rather heavy, and so the resulting reversible semantics are overly complex. This is a particularly notorious limitation in the work of Mezzina and P\'{e}rez in~\cite{DBLP:conf/ppdp/MezzinaP17}, which addresses reversibility in the context of concurrent processes which exchange messages following \emph{choreographies}, as defined by \emph{multiparty session types}~\cite{HYC08}. The reversible semantics developed in~\cite{DBLP:conf/ppdp/MezzinaP17} is causally consistent; however, it is unclear whether it can be implemented as  actual tools for the  analysis of message-passing, concurrent programs.

In this paper, we describe a Haskell implementation of the reversible semantics proposed in~\cite{DBLP:conf/ppdp/MezzinaP17}. More precisely, we present a Haskell interpreter of message-passing programs written in the reversible process framework in~\cite{DBLP:conf/ppdp/MezzinaP17}. This allows us to assess in practice the benefits and features of the memories and mechanisms deployed in~\cite{DBLP:conf/ppdp/MezzinaP17} to enforce causally consistent reversibility. In this process, we have found the use of a functional programming language---and in particular, of Haskell---a natural choice. Haskell has a strong history in language design. Its type system and mathematical nature allow us to faithfully implement the formal semantics and trust that our implementation is correct. In particular, algebraic data types (sums and products) are invaluable in expressing grammars and recursive data structures. 

\section{The Process Model}
\section{Introduction}\label{introduction}

This thesis describes an implementation of theoretical work in the area
of concurrent programming. In particular it concerns the use of formal
tools to check the correctness of message-passing programs and allow for
flexible error handling.

An example of a class of errors in message-passing are
\textbf{deadlocks}. Consider this example of a receive on an empty
channel:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    channel }\OtherTok{<-}\NormalTok{ Channel.new}
    \CommentTok{-- will block forever}
\NormalTok{    message }\OtherTok{<-}\NormalTok{ Channel.receive channel}
\end{Highlighting}
\end{Shaded}

\emph{This snippet uses Haskell's do-notation. the \texttt{\textless{}-}
is used to bind the result of an effectful computation - like receiving
from a channel. See also Appendix \ref{do-notation}}

No value will ever be sent on the channel, so the receive blocks
forever: it cannot make any progress.

Failing gracefully is challenging in a concurrent context: the state of
the application is typically spread over multiple locations which makes
it hard to determine where the error originates and how to compensate
for it.

Consider the following example: if Bob fails in receiving a message or
loses a message, he will have to repeat the \texttt{receive}, but also
inform Alice to send the message again.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{alice channel }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    Channel.send channel }\StringTok{"hello, my name is"}
\NormalTok{    Channel.send channel }\StringTok{"Alice"}
\NormalTok{    response }\OtherTok{<-}\NormalTok{ Channel.receive channel}
    
\NormalTok{bob channel }\FunctionTok{=} 
\NormalTok{    _ }\OtherTok{<-}\NormalTok{ Channel.receive channel }
\NormalTok{    name }\OtherTok{<-}\NormalTok{ Channel.receive channel}
\NormalTok{    Channel.send (}\StringTok{"Hello, "} \FunctionTok{++}\NormalTok{ name) }
\end{Highlighting}
\end{Shaded}

Moving back to the initial state is non-trivial. How can we be sure that
we have reverted all our actions? What is the minimal amount of
information (and memory) we need for a valid reversal?

The framework presented by Mezinna \& Pérez (PPDP'17) \cite{PPDP} (from
here on referenced as ``the PPDP'17 paper'') sets out to address both
these issues. The paper develops a theoretical approach, using
techniques from programming languages and concurrency. However, it does
not consider how the presented approach can be implemented in an actual
programming language. In earlier work during a short programming project
we have looked at combining the CaReDeb debugger \cite{caredeb} with the
PPDP'17 paper. Here we go further and look at how well the ideas
presented in the PPDP'17 paper translate to a programming context, and
whether the resulting system turns out to be convenient to use.

In answering these questions this bachelor's thesis makes the following
contributions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  We begin by analyzing the three core components of the PPDP'17 paper:

  A process calculus, multiparty session types
  \cite{DBLP:conf/esop/HondaVK98,DBLP:conf/popl/HondaYC08} and a
  reversible semantics. At the same time we give the encoding of the
  formal definitions of these components into Haskell data types.

  \begin{itemize}
  \item
    First, we define and implement a \textbf{process calculus} from its
    foundations. Later, we use the \texttt{Free} monad to provide
    convenient syntax.
  \item
    Next, we look at \textbf{multiparty session types} for the
    implemented calculus. The session types feature nested recursion and
    labelled choice.
  \item
    Finally, we consider \textbf{a reversible semantics} given the two
    previous concepts. In particular, we look at the information that
    needs to be preserved when moving forward in order maintain causal
    consistency.
  \end{itemize}
\end{enumerate}

The rest of the document is structured as follows: Section
\ref{the-main-idea} introduces the three key foundations from the
PPDP'17 paper and how they can be encoded into Haskell data types.
Section \ref{combining} shows how the data types can be used to
implement forward and backward operational semantics and provide the
other mechanics needed to evaluate the program. Section
\ref{free-monad-dsl} provides a more convenient syntax for writing
(reversible) message-passing programs. Appendices \ref{performing-io}
through \ref{scheduling-code} give background and extra examples for the
Haskell concepts and terminology used in the paper.

\section{The Main Idea}\label{the-main-idea}

The PPDP'17 paper builds a programming model that features three basic
concepts: a process calculus, multiparty session types and a reversible
semantics. The result of combining these ideas allows runtime
verification of programs, with the possibility of dealing with failure
in a flexible way.

The process calculus is a low-level programming language that allows
concurrent communication. The multiparty session types defined in the
PPDP'17 paper dynamically validate the communication a process performs
against a protocol. Finally, a reversible semantics for the process
calculus in combination with local types derived from multiparty session
types make it possible to reverse the evaluation of a program. Reversing
gives the ability to recover from errors or to safely fail.

In this section we show how these three concepts are formally defined in
the PPDP'17 paper and how they are implemented in our Haskell
implementation.

\subsection{Process Calculi}\label{process-calculi}

As already mentioned, a process calculus is a minimal programming
language that can model concurrent communication. We will start by
considering a well-understood existing calculus: the \(\pi\)-calculus.
Next we will look at how the PPDP'17 paper extends it and finally give
an implementation as a Haskell data type.

The \(\pi\)-calculus is to concurrent computation much like what the
\(\lambda\)-calculus is for sequential computing: a simple model that is
convenient for reasoning about a program's correctness. The syntax of
the \(\pi\)-calculus is defined as:

\begin{align*}
P, Q, R ::= \, & \overline{x} \langle y \rangle.P \,\,\, \, \, &\text{Send the value }y\text{ over channel }x\text{, then run }P \\
|\,\,\, & x(y).P \,\,\, \, \, & \text{Receive on channel }x\text{, bind the result to }y\text{, then run }P \\
|\,\,\, & P|Q \,\,\, \, \, \, \, \, \, &\text{Run }P\text{ and }Q\text{ simultaneously} \\
|\,\,\, & (\nu x)P  \,\,\, &\text{Create a new channel }x\text{ local to } P \text{ and run }P \\
|\,\,\, & !P \,\,\, &\text{Repeatedly spawn copies of }P \\
|\,\,\, & 0 & \text{Terminate the process} \\
|\,\,\, & P+Q \,\,\, \, \, \, \, \, \, &\text{Non-deterministic choice between }P\text{ and }Q\\
\end{align*}

The relevant part of the operational semantics for this paper is the
reduction of send and receive: a \(\pi\)-calculus term can reduce when
there is a send and a receive over the same channel running in parallel:

\[\overline{x}\langle z \rangle.P\, |\, x(y).Q \rightarrow P | Q[z/y]\]

With this syntax we can construct programs like so:

\[(\nu x)(\overline{x}\langle 42 \rangle.0\, |\, x(y).0)\]

This program can be read as ``create a channel \(x\) and then in
parallel send 42 over \(x\) then terminate, and receive a value on \(x\)
and bind it to the name \(y\) then terminate.'' The \(\pi\)-calculus is
much too low-level to write real programs in, but it can compute any
computable function (because the \(\lambda\)-calculus can be encoded
into it \cite{milner1992functions}).

The PPDP'17 paper makes a few generalizations to this calculus. Their
calculus is given by the syntax in Fig. \ref{fig:process-syntax}.

\begin{figure}[h!]
\begin{align*}
P, Q ::= \, 
        & \bout{u}{V}{P} \,\,\, \, \, &\text{Send the value }V\text{, then run }P \\
|\,\,\, & \binp{u}{x}{P} \,\,\, \, \, & \text{Receive and bind the result to }x\text{, then run }P \\
|\,\,\, &  \bsel{u}{\lbl_i. P_i}_{i\in I}\,\,\, \, \, & \text{Select an option, then broadcast the choice, then run }P_i \\
|\,\,\, & \bbra{u}{\lbl_i:P_i}_{i \in I} \,\,\, \, \, & \text{Offer options, receive a choice by the selector, then run } P_i \\
|\,\,\, & (P\,|\,Q) \,\,\, \, \, \, \, \, \, &\text{Run }P\text{ and }Q\text{ simultaneously} \\
|\,\,\, & \rvar{X} \,|\, \recp{X}{P} \,\,\, &\text{Variable and function abstraction}\\
|\,\,\, & \appl{V}{u} \,\,\, &\text{function application} \\
|\,\,\, & \news{n}P \,\,\, &\text{name restriction: make $n$ local in a term} \\
|\,\,\, & \inact \,\,\, &\text{terminate} \\
% P,Q \bnfis & 
%     \bout{u}{V}{P}  \sbnfbar  \binp{u}{x}{P} 
% \sbnfbar \bsel{u}{\lbl_i. P_i}_{i\in I} \sbnfbar \bbra{u}{\lbl_i:P_i}_{i \in I}
%  \\
%  & 
%  \sbnfbar  P \Par Q \sbnfbar  {\rvar{X} \sbnfbar \recp{X}{P}} 
%             \sbnfbar  
%  {\appl{V}{u}}  
% \sbnfbar \news{n} P \sbnfbar \inact
\end{align*}
\caption{\textbf{Syntax of Processes}}
\label{fig:process-syntax}
\end{figure}

\begin{figure}
\begin{align*}
u,w  \bnfis& n \sbnfbar x,y,z
\qquad \quad
n,n' \bnfis a,b \sbnfbar \ep{s}{p}
\\
 {v},  {v}'  \bnfis &  \true \sbnfbar \false \sbnfbar \cdots
\\
V,W \bnfis & {a,b} \sbnfbar  x,y,z \sbnfbar  v, v' \sbnfbar {\abs{x}{P}}
\end{align*}
\caption{\textbf{Values:}
Names $a,b,c$ (resp. $s,s'$) range over shared (resp. session) names.
We use session names indexed by participants, denoted $s_{[p]},s_{[q]}$.
Names $n,m$ are session or shared names. First-order values $v,v'$ 
include base values and constants. Variables are denoted by $x,y$ and
recursive variables are denoted by $X,Y$. The syntax of values V includes shared names, 
first-order values, but also name abstractions
(higher-order values) $\lambda x. P$, where $P$ is a process.
}
\end{figure}

The PPDP'17 paper preserves sending, receiving and parallel, and allow
recursion and termination. Channel creation is still part of the grammar
(the \(n\) in \(\news{n}P\) can take a session name \(s_{[p]}\)) but is
restricted to mean that all endpoints in \(P\) are simultaneously bound.
In practice this means that there is only one globally available message
channel. This global channel is implemented as a queue which means that
sends are non-blocking.

The primary extension is choice: where the \(\pi\)-calculus has
non-deterministic choice between \(\pi\)-terms, the process calculus has
labeled deterministic choice. The choice is determined by the state of
the program. The selector picks a label and sends it to the offerer.
Both parties will coordinate to pick the branch that the label
corresponds to and discard the alternative branches. Choice could be
implemented as a combination of send/receive and if-then-else, but they
are primitives here because each branch can have a different type (this
will become clearer in Section \ref{session-types}).

Finally, we allow the sending of thunks - functions that take
\texttt{Unit} as their argument and return a process term (i.e.~a piece
of program that can be executed). The fact that we can send programs -
and not just values - means that our calculus is a higher-order
calculus. The sending of thunks provides protocol delegation via
abstraction passing (see Section \ref{abstraction-passing}).

A side-effect of the function values is that there are two ways of
defining recursion: using the \(\mu X.P\) process constructor or using
the \(\lambda x.P\) value constructor. In the implementation the former
has been removed.

\subsection{Implementing the PPDP'17 calculus in
Haskell}\label{implementing-the-ppdp17-calculus-in-haskell}

The implementation uses an algebraic data type (union type/sum type) to
encode all the constructors of the grammar. We use the \texttt{Fix} type
(Appendix \ref{fix}) to factor out recursion from the grammar.
\texttt{Fix} is the fixed point type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Fix}\NormalTok{ f }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (f (}\DataTypeTok{Fix}\NormalTok{ f))}
\end{Highlighting}
\end{Shaded}

\texttt{Fix} allows us to concisely express an infinite nesting of a
type (of the shape \texttt{f\ (f\ (f\ (f\ (..))))}). Such a type will
look like a tree. For the values of this type to be finite, the
\texttt{f} must have a leaf constructor. Take for instance this simple
expression language

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Expr}
    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{Add} \DataTypeTok{Expr} \DataTypeTok{Expr} 
\end{Highlighting}
\end{Shaded}

\texttt{Literal} is the only constructor that can occur as a leaf, and
\texttt{Add} is the only node. Using \texttt{Fix} we can equivalently
write

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ExprF}\NormalTok{ next}
    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{Add}\NormalTok{ next next }
\end{Highlighting}
\end{Shaded}

In the above snippet, \texttt{next} is a placeholder or hole for an
arbitrarily deep nesting of \texttt{ExprF}s. The main usage of
\texttt{Fix} is that it gives traversals and folds of our syntax tree
for free because these are generically defined on \texttt{Fix}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{simple ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
\NormalTok{simple }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{42}\NormalTok{)}

\OtherTok{complex ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
\NormalTok{complex }\FunctionTok{=} 
    \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Add}\NormalTok{ (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{40}\NormalTok{)) (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

The above snippet shows that defining values of type \texttt{Fix\ ExprF}
requires wrapping of constructors with \texttt{Fix}. We will describe a
better way of writing \texttt{Fix}ed values in Section
\ref{free-monad-dsl}.

The full definition of \texttt{Program} is given below. As mentioned we
omit the process-level recursion.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Participant} \FunctionTok{=} \DataTypeTok{String}
\KeywordTok{type} \DataTypeTok{Identifier} \FunctionTok{=} \DataTypeTok{String}

\KeywordTok{type} \DataTypeTok{Program}\NormalTok{ value }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{ProgramF}\NormalTok{ value) }

\KeywordTok{data} \DataTypeTok{ProgramF}\NormalTok{ value next }
    \CommentTok{-- communication primitives}
    \FunctionTok{=} \DataTypeTok{Send} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ value ::}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \DataTypeTok{Receive} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ variableName ::} \DataTypeTok{Identifier}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next  }
\NormalTok{        \}}

    \CommentTok{-- choice primitives}
    \FunctionTok{|} \DataTypeTok{Offer} \DataTypeTok{Participant}\NormalTok{ (}\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, next))}
    \FunctionTok{|} \DataTypeTok{Select} \DataTypeTok{Participant}\NormalTok{ (}\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, value, next))}

    \CommentTok{-- other constructors }
    \FunctionTok{|} \DataTypeTok{Parallel}\NormalTok{ next next }
    \FunctionTok{|} \DataTypeTok{Application} \DataTypeTok{Identifier}\NormalTok{ value}
    \FunctionTok{|} \DataTypeTok{NoOp}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

We also need values in our language. To write more interesting examples
we extend the types of values that can be used from names, booleans and
functions to also include references, integers, strings, and basic
integer and logic operators.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Value} 
    \FunctionTok{=} \DataTypeTok{VBool} \DataTypeTok{Bool}
    \FunctionTok{|} \DataTypeTok{VInt} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{VString} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{VUnit}
    \FunctionTok{|} \DataTypeTok{VIntOperator} \DataTypeTok{Value} \DataTypeTok{IntOperator} \DataTypeTok{Value} 
    \FunctionTok{|} \DataTypeTok{VComparison} \DataTypeTok{Value} \DataTypeTok{Ordering} \DataTypeTok{Value}
    \FunctionTok{|} \DataTypeTok{VFunction} \DataTypeTok{Identifier}\NormalTok{ (}\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{)}
    \FunctionTok{|} \DataTypeTok{VReference} \DataTypeTok{Identifier} 
    \FunctionTok{|} \DataTypeTok{VLabel} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

We can now write the send/receive example from the Introduction as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{example }\FunctionTok{=} 
    \DataTypeTok{Fix} 
\NormalTok{        ( }\DataTypeTok{Parallel} 
\NormalTok{            (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Send} \StringTok{"me"}\NormalTok{ (}\DataTypeTok{VInt} \DecValTok{42}\NormalTok{) (}\DataTypeTok{Fix} \DataTypeTok{NoOp}\NormalTok{)))}
\NormalTok{            (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Receive} \StringTok{"you"} \StringTok{"y"}\NormalTok{ (}\DataTypeTok{Fix} \DataTypeTok{NoOp}\NormalTok{)))}
\NormalTok{        )}
\end{Highlighting}
\end{Shaded}

While the above is easily manipulatable with pattern matching and
functions from the \texttt{Fix} module, it is very hard to write clear
examples in this style. Longer expressions need ever more parentheses
and in general there is too much syntactical clutter. We will get back
to designing a better syntax for defining programs in Section
\ref{free-monad-dsl}.

\subsection{Multiparty Session Types}\label{session-types}

As programmers we would like our programs to work as we expect. With
concurrent programs, fitting the whole program in one's head becomes
increasingly difficult as the application becomes larger and program
behavior becomes harder to predict.

Most programmers are familiar with data types. Compilers use data types
to typecheck programs. Programs that typecheck are statically guaranteed
to not have certain classes of bugs. Type systems range from very loose
(dynamic languages like Javascript and Python) to very restrictive (Coq,
Agda, Idris).

In the late 90s, a similar tool was developed for typing and checking
the interaction between concurrent processes: Session types. Session
types abstract protocols to enforce three key properties:

\begin{itemize}
\tightlist
\item
  \textbf{Order:} every protocol participant has a sequence of sends and
  receives that it must perform;
\item
  \textbf{Progress:} every sent message is eventually received;
\item
  \textbf{Communication Safety:} sender and receiver always agree about
  the type of the exchanged values
\end{itemize}

Next we will look at how these types are defined and how we can check
that our programs implement their session type.

\subsubsection{Global Types}\label{global-types}

The simplest non-trivial concurrent program has two participants. In
this case, the types of the two participants should be exactly dual: if
the one sends, the other must receive. However, for the multiparty use
case (three or more participants), things are not so simple as duality
is hard to define.

We need to define globally what communications occur in our protocol.
The snippet below is a basic global type where Carol and Bob first
exchange a value of type \texttt{Bool}, next Alice and Carol exchange a
value of type \texttt{Int} and finally the protocol ends:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{simple ::} \DataTypeTok{GlobalType} \DataTypeTok{String} \DataTypeTok{String}
\NormalTok{simple }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    message }\StringTok{"carol"} \StringTok{"bob"} \StringTok{"Bool"}
\NormalTok{    message }\StringTok{"alice"} \StringTok{"carol"} \StringTok{"Int"}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

We can see immediately that \textbf{safety and progress are guaranteed}:
Every communication has a send and receive, and they both must agree on
the type. We cannot construct a valid global type that does not check
for these properties. As a result, every program that implements a
global type also has these properties.

A more realistic scenario that we will use as a running example is the
three buyer protocol from the PPDP'17 paper. In this protocol, Alice and
Bob communicate with the Vendor about the purchase of some item:

\begin{align*}
G = ~&  \gtcom{A}{\texttt{V}}{\mathsf{title}}{~~\gtcom{\mathtt{V}}{\{A,B\}}{\mathsf{price}}{\\[-0.5mm] 
& \quad\gtcom{A}{B}{\mathsf{share}}{~~\gtcom{B}{\{A,\mathtt{V}\}}{\mathsf{OK}}{
\\[-0.5mm]
& \quad\quad \gtcom{B}{C}{\mathsf{share}}{~~\gtcom{B}{C}{\textcolor{blue}{\thunkt}}{
\\[-0.5mm]
& \quad\qquad \gtcom{B}{\mathtt{V}}{\mathsf{address}}{~~\gtcom{\mathtt{V}}{B}{\mathsf{date}}{\gend}}}}}}}}
\end{align*}

Near the end of the protocol, Bob has to leave and transfers the
remainder of his protocol to Carol. She will also be sent the code - a
\textbf{thunk process} denoted \(\textcolor{blue}{\thunkt}\) - to
complete Bob's protocol, and finish the protocol in his name by
evaluating the sent thunk.

The full definition of global types in the Haskell implementation is
given by

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{GlobalType}\NormalTok{ participant u }\FunctionTok{=} 
    \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{GlobalTypeF}\NormalTok{ participant u) }\DataTypeTok{Void}

\KeywordTok{data} \DataTypeTok{GlobalTypeF}\NormalTok{ participant u next}
    \FunctionTok{=} \DataTypeTok{Transaction} 
\NormalTok{        \{}\OtherTok{ from ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ to ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ tipe ::}\NormalTok{ u}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{  next }
\NormalTok{        \} }
    \FunctionTok{|} \DataTypeTok{Choice} 
\NormalTok{        \{}\OtherTok{ from ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ to ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ options ::} \DataTypeTok{Map} \DataTypeTok{String}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \DataTypeTok{End}
    \FunctionTok{|} \DataTypeTok{RecursionPoint}\NormalTok{ next}
    \FunctionTok{|} \DataTypeTok{RecursionVariable}
    \FunctionTok{|} \DataTypeTok{Weaken}\NormalTok{ next}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can now see why choice is useful: it allows us to branch on the
session type level. For instance, one branch can terminate the protocol,
and the other can start from the beginning.

The final three constructors are required for supporting nested
recursion and taken from \cite{van2017session}. A
\texttt{RecursionPoint} is a point in the protocol that we can later
jump back to. A \texttt{RecursionVariable} triggers jumping to a
previously encountered \texttt{RecursionPoint}. By default it will jump
to the closest and most-recently encountered \texttt{RecursionPoint},
but \texttt{WeakenRecursion} makes it jump one \texttt{RecursionPoint}
higher, encountering 2 weakens will jump 2 levels higher etc.

Using \texttt{Monad.Free} (Appendix \ref{free-monad}), we can write
examples with a more idiomatic Haskell syntax.

The snippet below shows the use of nested recursion. There is an outer
loop that will perform a piece of protocol or end, and an inner loop
that sends messages from \texttt{A} to \texttt{B}. When the inner loop
is done, control flow returns to the outer loop.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import }\DataTypeTok{GlobalType} \KeywordTok{as} \DataTypeTok{G}

\NormalTok{G.recurse }\FunctionTok{$} \CommentTok{-- recursion point 1}
\NormalTok{    G.oneOf }\DataTypeTok{A} \DataTypeTok{B}
\NormalTok{        [ (}\StringTok{"loop"}
\NormalTok{          , G.recurse }\FunctionTok{$} \CommentTok{-- recursion point 2}
\NormalTok{                G.oneOf }\DataTypeTok{A} \DataTypeTok{B}
\NormalTok{                    [ (}\StringTok{"continueLoop"}\NormalTok{, }\KeywordTok{do} 
\NormalTok{                        G.message }\DataTypeTok{A} \DataTypeTok{B} \StringTok{"date"}
                        \CommentTok{-- jumps to recursion point 2}
\NormalTok{                        G.recursionVariable}
\NormalTok{                      )}
            
\NormalTok{                    , (}\StringTok{"endInnerLoop"}\NormalTok{, }\KeywordTok{do} 
                        \CommentTok{-- jumps to recursion point 1}
\NormalTok{                        G.weakenRecursion G.recursionVariable}
\NormalTok{                      )}
\NormalTok{                    ]}
\NormalTok{          )}
\NormalTok{        , (}\StringTok{"end"}\NormalTok{, G.end)}
\NormalTok{        ]}
\end{Highlighting}
\end{Shaded}

Similarly, the three buyer example can be written as:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- a data type representing the participants}
\KeywordTok{data} \DataTypeTok{MyParticipants} \FunctionTok{=} \DataTypeTok{A} \FunctionTok{|} \DataTypeTok{B} \FunctionTok{|} \DataTypeTok{C} \FunctionTok{|} \DataTypeTok{V} 
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Ord}\NormalTok{, }\DataTypeTok{Enum}\NormalTok{, }\DataTypeTok{Bounded}\NormalTok{)}

\CommentTok{-- a data type representing the used types }
\KeywordTok{data} \DataTypeTok{MyType} \FunctionTok{=} \DataTypeTok{Title} \FunctionTok{|} \DataTypeTok{Price} \FunctionTok{|} \DataTypeTok{Share} \FunctionTok{|} \DataTypeTok{Ok} \FunctionTok{|} \DataTypeTok{Thunk} \FunctionTok{|} \DataTypeTok{Address} \FunctionTok{|} \DataTypeTok{Date}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Ord}\NormalTok{)}

\CommentTok{-- a description of the protocol}
\OtherTok{globalType ::} \DataTypeTok{GlobalType.GlobalType} \DataTypeTok{MyParticipants} \DataTypeTok{MyType}
\NormalTok{globalType }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title} 
\NormalTok{    messages }\DataTypeTok{V}\NormalTok{ [}\DataTypeTok{A}\NormalTok{, }\DataTypeTok{B}\NormalTok{] }\DataTypeTok{Price} 
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share} 
\NormalTok{    messages }\DataTypeTok{B}\NormalTok{ [}\DataTypeTok{A}\NormalTok{, }\DataTypeTok{V}\NormalTok{] }\DataTypeTok{Ok} 
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{C} \DataTypeTok{Share}
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{C} \DataTypeTok{Thunk}
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{V} \DataTypeTok{Address}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Date}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}

\subsubsection{Local Types}\label{local-types}

A global type can contain inherent parallelism: the order of its steps
is not fully defined. For instance in
\texttt{messages\ V\ {[}A,\ B{]}\ Price}, \texttt{V} can send the price
first to \texttt{B} or first to \texttt{A}: both are valid according to
the type. This parallelism makes checking for correctness against a
global type difficult and also unpractical because the global type
mentions all participants. The solution is to project the global type
onto its participants, creating a local type.

The local type is an ordered list of communication actions that the
participant must execute to comply with the protocol. Thus the
\textbf{order} property is enforced for local types.

The projection is mostly straightforward, except for choice. Because we
allow recursion, a branch of a choice may recurse back to the beginning.
When this occurs, all participants have to jump back to the beginning,
so every choice must be communicated to all participants.

The PPDP'17 paper and many other papers deal with this problem by
disallowing different branches using different participants. In practice
this means that all branches must perform the same communication to
satisfy the global type, even if the communication is not needed in
every branch (some branches may have dummy communication).

In the Haskell implementation we use a different method where every
choice causes a broadcast of that choice to the other participants. Once
again, some participants may not need the information about the choice
and the communication with them is just to satisfy the type checker.

The underlying is that problem global types only have meaning with
respect to their projection into local types. If a global type cannot be
projected - even though it is grammatically valid - it has no meaning. A
simple projection disallows many (grammatically valid) global types and
implementations. A more sophisticated projection allows more global
types, but with the associated cost of more dummy communications.

\begin{figure}[]
{
\begin{align*}
\tproj{(\gtcom{p}{q}{U}{G})}{\gpart{r}} & = 
\begin{cases}
\ltout{q}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{p}$} \\
\ltinp{p}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{q}$} \\
(\tproj{G}{\gpart{r}}) &  \text{if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$}
\end{cases}
\\
\tproj{(\gtcho{p}{q}{l_i}{G_i})}{\gpart{r}}  
& 
{= 
\begin{cases}
\ltsel{q}{\lbl_i}{(\tproj{G_i}{\gpart{r}})}{i}{I}  & \text{ if $\gpart{r} = \gpart{p}$} \\
\ltbra{p}{\lbl_i}{\tproj{G_i}{\gpart{r}}}{i}{I}  & \text{ if $\gpart{r} = \gpart{q}$} \\
(\tproj{{G_1}}{\gpart{r}}) &  \text{ if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$ and} \\ 
& \text{~~$\forall i, j \in I. \tproj{{G_i}}{\gpart{r}} = \tproj{{G_j}}{\gpart{r}}$}
\end{cases}
}
\\
\tproj{(\mu X. G)}{\gpart{r}} &= 
\begin{cases}
\mu X. \tproj{G}{\gpart{r}} & \text{if $\gpart{r}$ occurs in $G$}
\\
\lend & \text{otherwise}
\end{cases}
\\
\tproj{X}{\gpart{r}} & = X
\qquad
\tproj{\gend}{\gpart{r}} = \lend
\end{align*}
}
\vspace{-4mm}
\caption{Projection of a global type $G$ onto a participant $\gpart{r}$ from PPDP'17.\label{f:proj}}
\end{figure}

\subsection{A Reversible Semantics}\label{a-reversible-semantics}

The third component of the system a reversible semantics. The idea here
is that we can move back to previous program states, reversing forward
steps.

Reversibility is useful in a concurrent setting when an error is
encountered but the current state is invalid. In such a case the program
should revert to its initial state, from which next steps can be
considered (e.g.~to retry or to log the failure).

The naive way to achieve reversibility in the semantics is to store a
snapshot of the initial state, but the memory consumption of this method
is too large for this method to be practical. For instance, the system
may interact with a large database. Keeping many copies of the database
around is inconvenient and may not even be physically possible.

The PPDP'17 paper provides a convenient approach tailored to the process
calculus and local types that we have seen. For every forward step, just
enough information is stored to undo it. Conceptually, we are leaving
behind a trail of breadcrumbs so we can always find our way back.

The challenge, then, is to find what the minimal amount of information
actually is for every instruction. The PPDP'17 paper tells us that
broadly, we need to track information about two things: the type and the
process.

For the type we define a new data type called \texttt{TypeContext}. It
contains the actions that have been performed and for some of them it
stores a bit of extra information like the \texttt{owner}.

On the process level there are four things that we need to track:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Used variable names in receives

  The rest of the program depends on the name that is assigned to a
  received value, like \texttt{decision} in the example below.\\
  When reverting, we need to reinstate the name that the rest of the
  program expects.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decision }\OtherTok{<-}\NormalTok{ H.receive    }
\NormalTok{H.send decision          }
\end{Highlighting}
\end{Shaded}

  When we advance the snippet above, \texttt{decision} is internally
  renamed to \texttt{var1} and this binding is added to the store.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{H.send var1        }
\end{Highlighting}
\end{Shaded}

  Now we want to move back. We can't simply create a new name: if we
  then move forward again, \texttt{var1} will not be defined.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var2 }\OtherTok{<-}\NormalTok{ H.receive       }
\NormalTok{H.send var1             }
\end{Highlighting}
\end{Shaded}

  Instead, the receive needs to store the name of the value its result
  is bound to, in this case \texttt{var1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{var1 }\OtherTok{<-}\NormalTok{ H.receive}
\NormalTok{H.send var1}
\end{Highlighting}
\end{Shaded}

  But we also store the original name (given by the programmer) and
  actually restore that. The original name can helpful in debugging
  programs, to know what value is actually used:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{decision }\OtherTok{<-}\NormalTok{ H.receive}
\NormalTok{H.send decision}
\end{Highlighting}
\end{Shaded}
\item
  Unused branches

  When a choice is made and then reverted, we want all our options to be
  available again. Currently, another label cannot actually be selected
  after reverting: the selected label depends only on the values of
  variables in the program. Future work may make it possible to also use
  the failure information to influence the choice made.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Zipper}\NormalTok{ a }\FunctionTok{=}\NormalTok{ (}\DataTypeTok{List}\NormalTok{ a, a, }\DataTypeTok{List}\NormalTok{ a)}

\KeywordTok{data} \DataTypeTok{OtherOptions}
    \FunctionTok{=} \DataTypeTok{OtherSelections}\NormalTok{ (}\DataTypeTok{Zipper}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Value}\NormalTok{, }\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{))}
    \FunctionTok{|} \DataTypeTok{OtherOffers}\NormalTok{ (}\DataTypeTok{Zipper}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

  The code above shows how the choices are stored. We need to remember
  which choice was made, and the order of the options is important. We
  use a \texttt{Zipper} to store the elements in order and use the
  central \texttt{a} to store the choice that was made.
\item
  Function applications

  When applying a function we lose information about the applied
  function and the argument. Therefore we store them in a map and
  associate them with a unique identifier. This identifier is given to
  the \texttt{Application} constructor so when stepping backward the
  function and the argument can be recovered.

  You might think that a stack would be a simpler solution, but a stack
  can give invalid behavior. Say that a participant is running in two
  locations, and the last-performed action at both locations is a
  function application. Now we want to undo both applications, but the
  order in which to undo them is undefined: we need both orders to work.
  When the application keeps track of exactly which function and
  argument it used the end result is always the same. Only using a stack
  could mix up the applications.
\item
  Messages on the channel

  When a value is sent, the sender loses track of what has been sent.
  Therefore, reverting a send/receive pair must move the value from the
  receiver via the queue back to the sender. Fig.
  \ref{fig:reverse-send-receive} below illustrates this process:

  \begin{figure}[h!]
  \begin{align*}
  \includegraphics[scale=0.60]{img/queue-history-stack.pdf}
  \end{align*}
  \caption{Reversal of send and receive}
  \label{fig:reverse-send-receive}
  \end{figure}

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \tightlist
  \item
    \textbf{receive}: the value 42 is popped from the queue but pushed
    onto the history stack.
  \item
    \textbf{roll receive}: Now when the receive is rolled, the value is
    moved back from the history stack onto the queue.
  \item
    \textbf{roll send}: When the send is rolled the value is moved from
    the head of the queue into the sender's process.
  \end{enumerate}
\end{enumerate}

\subsection{Abstraction Passing is Protocol
Delegation}\label{abstraction-passing}

Protocol delegation is where a participant can delegate (a part of)
their protocol to be fulfilled by another participant. An example of
where this idea is useful is a load balancing server: from the client's
perspective, the server handles the request, but actually the load
balancer delegates incoming requests to workers. The client does not
need to be aware of this implementation detail.

Recall the definition of \texttt{ProgramF}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ProgramF}\NormalTok{ value next }
    \CommentTok{-- communication primitives}
    \FunctionTok{=} \DataTypeTok{Send} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ value ::}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

The \texttt{ProgramF} constructors that move the local type forward
(send/receive, select/offer) have an \texttt{owner} field that stores
whose local type they should be checked agains and modfiy. This field is
also present in the \texttt{TypeContext}.

Because we allow references to values in the implementation, all
references in a function have to be dereferenced before it can be safely
sent over a channel.

\section{Putting it all together}\label{combining}

With all the definitions encoded, we can now define forward and backward
evaluation of our system. Our aim is to implement:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{forward  ::} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{Session}\NormalTok{ ()}
\OtherTok{backward ::} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{Session}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

These functions take a \texttt{Location}, our way of modeling different
threads or machines, and tries to move the process at that location
forward or backward. The \texttt{Session} type contains the
\texttt{ExecutionState}, the state of the session (all programs, local
types, variable bindings, etc.), and can throw errors of type
\texttt{Error}, for instance when an unbound variable is used.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Session}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{StateT} \DataTypeTok{ExecutionState}\NormalTok{ (}\DataTypeTok{Except} \DataTypeTok{Error}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}

\emph{See also Appendices \ref{state} on \texttt{StateT} and
\ref{except} on \texttt{Except}}

The semantics in the PPDP'17 paper guides how we store the execution
state. Some data is bound to its location (for instance the process that
is running) and other data is bound to its participant (for instance the
local type).

The information about a participant grouped in a type called
\texttt{Monitor}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Monitor}\NormalTok{ value tipe }\FunctionTok{=} 
    \DataTypeTok{Monitor} 
\NormalTok{        \{}\OtherTok{ _localType ::} \DataTypeTok{LocalTypeState}\NormalTok{ tipe}
\NormalTok{        ,}\OtherTok{ _recursiveVariableNumber ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ _recursionPoints ::} \DataTypeTok{List}\NormalTok{ (}\DataTypeTok{LocalType}\NormalTok{ tipe)}
\NormalTok{        ,}\OtherTok{ _usedVariables ::} \DataTypeTok{List} \DataTypeTok{Binding} 
\NormalTok{        ,}\OtherTok{ _applicationHistory ::} \DataTypeTok{Map} \DataTypeTok{Identifier}\NormalTok{ (value, value)}
\NormalTok{        ,}\OtherTok{ _store ::} \DataTypeTok{Map} \DataTypeTok{Identifier}\NormalTok{ value }
\NormalTok{        \}}
        \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{)}

\KeywordTok{data} \DataTypeTok{Binding} \FunctionTok{=} 
    \DataTypeTok{Binding} 
\NormalTok{        \{}\OtherTok{ _visibleName ::} \DataTypeTok{Identifier}
\NormalTok{        ,}\OtherTok{ _internalName ::} \DataTypeTok{Identifier} 
\NormalTok{        \}}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\item
  \texttt{\_localType} contains \texttt{TypeContext} and
  \texttt{LocalType} stored as a tuple. This tuple gives a curser into
  the local type, where everything to the left is the past and
  everything to the right is the future.
\item
  The next two fields are for keeping track of recursion in the local
  type. the \texttt{\_recursiveVariableNumber} is an index into the
  \texttt{\_recursionPoints} list: when a \texttt{RecursionVariable} is
  encountered we look at that index to find the new future local type.
\item
  \texttt{\_usedVariables} and \texttt{\_applicationHistory} are used in
  reversal. As mentioned in Section \ref{a-reversible-semantics}, used
  variable names need to be stored in order to be able to use them when
  reversing. We store them in a stack keeping both the original name
  given by the programmer and the generated unique internal name. For
  function applications we use a \texttt{Map} indexd by unique
  identifiers that stores function and argument.
\item
  Finally \texttt{\_store} is a variable store with the currently
  defined bindings. Variable shadowing - where two processes of the same
  participant define the same variable name - is not an issue, because
  variables are assigned a guaranteed unique name.
\end{itemize}

We can now define \texttt{ExecutionState}. It contains some counters for
generating unique variable names, a monitor for every participant and a
program for every location. Additionally, every location has a default
participant and a stack for unchosen branches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ExecutionState}\NormalTok{ value }\FunctionTok{=} 
    \DataTypeTok{ExecutionState} 
\NormalTok{        \{}\OtherTok{ variableCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ locationCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ applicationCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ participants ::} \DataTypeTok{Map} \DataTypeTok{Participant}\NormalTok{ (}\DataTypeTok{Monitor}\NormalTok{ value }\DataTypeTok{String}\NormalTok{)}
\NormalTok{        ,}\OtherTok{ locations ::} \DataTypeTok{Map} \DataTypeTok{Location} 
\NormalTok{                 (}\DataTypeTok{Participant}\NormalTok{ , }\DataTypeTok{List} \DataTypeTok{OtherOptions}\NormalTok{ , }\DataTypeTok{Program}\NormalTok{ value)}
\NormalTok{        ,}\OtherTok{ queue ::} \DataTypeTok{Queue}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ isFunction ::}\NormalTok{ value }\OtherTok{->} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Identifier}\NormalTok{, }\DataTypeTok{Program}\NormalTok{ value)}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

The message queue is global and thus also lives in the
\texttt{ExecutionState}. Finally we need a way of inspecting values, to
see whether they are functions and if so, to extract their bodies for
application.

\subsection{Running and Debugging Programs}\label{running-debugging}

Finally, we want to be able to run our programs. The implementation
offers mechanisms to step through a program interactively, and run it to
completion.

We can step through the program interactively in the Haskell REPL
environment (Appendix \ref{installing-and-running}). Assuming the
\texttt{ThreeBuyer} example is loaded, we can print the initial state of
our program:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ initialProgram}
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Send}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Next we introduce the \texttt{stepForward} and \texttt{stepBackward}
functions. They use mutability, normally frowned upon in Haskell, to
avoid having to manually keep track of the updated program state like in
the snippet below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{state1 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state0}
\NormalTok{state2 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state1}
\NormalTok{state3 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state2}
\end{Highlighting}
\end{Shaded}

Manual state passing is error-prone and inconvenient. We provide helpers
(that internally use \texttt{IORef}) to work around this issue. We must
first initialize the program state:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>} \KeywordTok{import }\DataTypeTok{Interpreter}
\FunctionTok{>}\NormalTok{ state }\OtherTok{<-}\NormalTok{ initializeProgram initialProgram}
\end{Highlighting}
\end{Shaded}

Then we can use \texttt{stepForward} and \texttt{stepBackward} to
evaluate the program:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l1"}\NormalTok{ state}
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Receive}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l4"}\NormalTok{ state }
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Receive}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

When the user tries an invalid step, an error is displayed. for instance
after \(l_1\) and \(l_2\) have been moved forward once like in the
snippet above, \(l_1\) cannot move forward (it needs to receive but
there is nothing in the queue) and not backward (\(l_4\), the receiver,
must undo its action first).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l1"}\NormalTok{ state}
\FunctionTok{***} \DataTypeTok{Exception}\FunctionTok{:} \DataTypeTok{QueueError} \StringTok{"Receive"} \DataTypeTok{EmptyQueue}
\DataTypeTok{CallStack}\NormalTok{ (from }\DataTypeTok{HasCallStack}\NormalTok{)}\FunctionTok{:}
\NormalTok{  error, called at }\FunctionTok{...} 
\FunctionTok{>}\NormalTok{ stepBackward }\StringTok{"l1"}\NormalTok{ state}
\FunctionTok{***} \DataTypeTok{Exception}\FunctionTok{:} \DataTypeTok{QueueError} \StringTok{"BackwardSend"} \DataTypeTok{EmptyQueue}\NormalTok{ state}
\DataTypeTok{CallStack}\NormalTok{ (from }\DataTypeTok{HasCallStack}\NormalTok{)}\FunctionTok{:}
\NormalTok{  error, called at }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Errors are defined as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Error} 
    \FunctionTok{=} \DataTypeTok{UndefinedParticipant} \DataTypeTok{Participant}
    \FunctionTok{|} \DataTypeTok{UndefinedVariable} \DataTypeTok{Participant} \DataTypeTok{Identifier}
    \FunctionTok{|} \DataTypeTok{SynchronizationError} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{LabelError} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{QueueError} \DataTypeTok{String} \DataTypeTok{Queue.QueueError}
    \FunctionTok{|} \DataTypeTok{ChoiceError} \DataTypeTok{ChoiceError}
    \FunctionTok{|} \DataTypeTok{Terminated}
\end{Highlighting}
\end{Shaded}

To fully evaluate a program, we use a round-robin scheduler that calls
\texttt{forward} on the locations in order. A forward step can produce
an error. There are two error cases that we can recover from:

\begin{itemize}
\item
  \textbf{blocked on receive}, either
  \texttt{QueueError\ \_\ InvalidQueueItem} or
  \texttt{QueueError\ \_\ EmptyQueue}: the process wants to perform a
  receive, but the expected item is not at the top of the queue yet. In
  this case we want to proceed evaluating the other locations so they
  can send the value that the erroring location expects. The \texttt{\_}
  in the patterns above means that we ignore the \texttt{String} field
  that is used to provide better error messages. Because no error
  message is generated, that field is not needed.
\item
  \textbf{location terminates} with \texttt{Terminated}: the execution
  has reached a \texttt{NoOp}. In this case we do not want to schedule
  this location any more.
\end{itemize}

Otherwise we continue until there are no active (non-terminated)
locations left. For code see Appendix \ref{scheduling-code}.

Running until completion (or error) is also available in the REPL:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ untilError initialProgram}
\DataTypeTok{Right}\NormalTok{ locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Fix} \DataTypeTok{NoOp}\NormalTok{)), }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Note that this scheduler can still get into deadlocks, for instance
consider these two equivalent global types:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{globalType1 }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Price} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{V} \DataTypeTok{A} \DataTypeTok{Price} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share} 

\NormalTok{globalType2 }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{V} \DataTypeTok{A} \DataTypeTok{Price} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Price} 
\NormalTok{    GlobalType.transaction }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share} 
\end{Highlighting}
\end{Shaded}

The second and third line are swapped. The communication they describe
is the same, but in practice they are very different. The first one will
run to completion, the second one can deadlock because \texttt{A} can
send a \texttt{Share} before \texttt{V} does. \texttt{B} expects the
share from \texttt{V} first, but the share from \texttt{A} is the first
in the queue. Therefore, no progress can be made.

\subsection{Properties of
Reversibility}\label{properties-of-reversibility}

The main property that a reversable semantics needs to preserve is
\emph{causal consistency}: the state that we reach when moving backward
is a state that could have been reached by moving forward only.

The global type defines a partial order on all the communication steps.
The relation of this partial order is causal dependency. Stepping
backward is only allowed when all its causally dependent actions are
undone. This guarantee is baked into every part of the semantics. For
instance, a send can only be undone when the receive is already undone,
because there is a data dependency between the two actions (the sent
value).

Causal consistency is formally proven for the PPDP'17 semantics. We
claim that the Haskell implementation is faithfull enough that causal
consistency is preserved.

\section{Convenient Syntax with the Free Monad}\label{free-monad-dsl}

The types we have defined for \texttt{Program}, \texttt{GlobalType} and
\texttt{LocalType} form recursive tree structures. Because they are all
new types, there is no easy way to traverse them. A common idiom is to
factor out recursion using \texttt{Data.Fix} (see Appendix
\ref{factoring-recursion}).

While a \texttt{Fix}ed data type is easy to manipulate and traverse, it
can be messy to write. The program below implements ``receive and bind
the value to \texttt{result}, then send 42'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{program }\FunctionTok{=}  
    \DataTypeTok{Fix} 
\NormalTok{        ( }\DataTypeTok{Receive} 
\NormalTok{            \{ owner }\FunctionTok{=} \StringTok{"Alice"}
\NormalTok{            , variableName }\FunctionTok{=} \StringTok{"result"}
\NormalTok{            , continuation }\FunctionTok{=} 
                  \DataTypeTok{Fix} 
\NormalTok{                    ( }\DataTypeTok{Send} 
\NormalTok{                        \{ owner }\FunctionTok{=} \StringTok{"Alice"}
\NormalTok{                        , value }\FunctionTok{=} \DataTypeTok{VInt} \DecValTok{42}
\NormalTok{                        , continuation }\FunctionTok{=} \DataTypeTok{Fix} \DataTypeTok{NoOp} 
\NormalTok{                        \}}
\NormalTok{                    )}
\NormalTok{              \}}
\NormalTok{        )}
\end{Highlighting}
\end{Shaded}

The syntax distracts from the goal of the program. \texttt{Program} and
\texttt{GlobalType} are types that we will write a lot manually, so
fixing this issue is important.

Conveniently, Haskell has a long tradition of embedded domain-specific
languages. In particular we can use a cousin of \texttt{Fix}, the
\texttt{Free} monad (Appendix \ref{free-monad}) to get access to
do-notation (Appendix \ref{do-notation}). Concretely, the do-notation
makes it possible instead of the above write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{program }\FunctionTok{=}\NormalTok{ compile }\StringTok{"Alice"} \FunctionTok{$} \KeywordTok{do}
\NormalTok{    result }\OtherTok{<-}\NormalTok{ receive}
\NormalTok{    send (}\DataTypeTok{VInt} \DecValTok{42}\NormalTok{)}
\NormalTok{    terminate}
\end{Highlighting}
\end{Shaded}

Behind the scenes, the do-notation produces a value of type
\texttt{HighLevelProgram\ a} using some helpers like \texttt{send} and
\texttt{terminate}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{HighLevelProgram}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{HighLevelProgram} 
\NormalTok{    (}\DataTypeTok{StateT}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{)) a)}
    \KeywordTok{deriving} 
\NormalTok{        ( }\DataTypeTok{Functor}\NormalTok{, }\DataTypeTok{Applicative}\NormalTok{, }\DataTypeTok{Monad}
\NormalTok{        , }\DataTypeTok{MonadState}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)}
\NormalTok{        , }\DataTypeTok{MonadFree}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{)}
\NormalTok{        )}

\OtherTok{send ::} \DataTypeTok{Value} \OtherTok{->} \DataTypeTok{HighLevelProgram}\NormalTok{ ()}
\NormalTok{send value }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    (participant, _) }\OtherTok{<-}\NormalTok{ State.get}
\NormalTok{    liftF (}\DataTypeTok{Send}\NormalTok{ participant value ())  }

\OtherTok{terminate ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{terminate }\FunctionTok{=}\NormalTok{ liftF }\DataTypeTok{NoOp}

\CommentTok{-- similar for receive, select, etc.}
\end{Highlighting}
\end{Shaded}

The above snippet introduces some new Haskell concepts that require some
background. Pure languages can simulate mutable state using a type
called \texttt{State} (Appendix \ref{state}). \texttt{State} is an
instance of monad (Appendix \ref{monads}) which makes it easy to chain
stateful computations. In this case our piece of state is a pair
\texttt{(Participant,\ Int)}: the participant is the owner of the block,
and the \texttt{Int} is a counter used to generate unique variable
names. To combine \texttt{State} with \texttt{Free} (and to combine two
monads in general) we need the \texttt{StateT} monad transformer
(Appendix \ref{state}).

In the \texttt{send} helper we use the unit type \texttt{()} as a
placeholder or hole. A continuation will need to fill the hole
eventually but it is not available yet. When a \texttt{HighLevelProgram}
is converted into a \texttt{Program}, we want to be sure there are no
remaining holes. In this particular case that means all branches must
end in \texttt{terminate}. We use the fact that
\texttt{terminate\ ::\ HighLevelProgram\ a} contains a free type
variable \texttt{a} which can unify with \texttt{Void}, the type with no
values. Thus \texttt{Free\ f\ Void} can contain no \texttt{Pure} because
the \texttt{Pure} constructor needs a value of type \texttt{Void}, which
don't exist. For more information see Appendix
\ref{well-formedness-free}.

\section{Discussion}\label{discussion}

\subsection{Benefits of pure functional
programming}\label{benefits-of-pure-functional-programming}

It has consistently been the case that sticking closer to the formal
model gives better code. The abilities that Haskell gives for directly
specifying formal statements is invaluable. The primary invaluable
feature is algebraic data types (ADTs) also known as tagged unions or
sum types.

Compare the formal definition and the Haskell data type for global
types.

\begin{align*}
    G, G'  \bnfis & \gtcom{p}{q}{U}{G} %\bnfbar 
    \sbnfbar
    \gtcho{p}{q}{\lbl_i}{G_i} %\\
    \sbnfbar %& 
    \mu X. G \sbnfbar X \sbnfbar \gend \\
\end{align*}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{GlobalTypeF}\NormalTok{ u next }\FunctionTok{=} 
    \DataTypeTok{Transaction}\NormalTok{ \{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{|} \DataTypeTok{Choice}\NormalTok{ \{}\FunctionTok{..}\NormalTok{\}  }\FunctionTok{|} \DataTypeTok{R}\NormalTok{ next }\FunctionTok{|} \DataTypeTok{V} \FunctionTok{|} \DataTypeTok{End} \FunctionTok{|} \DataTypeTok{Wk}\NormalTok{ next}
\end{Highlighting}
\end{Shaded}

The definitions correspond directly. Moreover, we know that these are
all the ways to construct a value of type \texttt{GlobalTypeF} and can
exhaustively match on all the cases. Functional languages have had these
features for a very long time. In recent years they have also made their
way into non-functional languages (Rust, Swift, Kotlin).

Secondly, purity and immutability are very valuable in implementing and
testing the reversible semantics. The type system can actually guarantee
that we have not forgotten to revert anything.

In a pure language, given functions
\texttt{f\ ::\ a\ -\textgreater{}\ b} and
\texttt{g\ ::\ b\ -\textgreater{}\ a} to prove that \(f\) and \(g\) are
inverses it is enough to prove (or to test for the domain you're
interested in) that

\begin{verbatim}
f . g = identity && g . f = identity
\end{verbatim}

In an impure language, even if the above equalities are observed we
cannot be sure that there were no side-effects. Because we do not need
to consider a context (the outside world) here, checking that
reversibility works is as simple as comparing initial and final states
for all backward transition rules.

\subsection{Concurrent Debuggers}\label{concurrent-debuggers}

As mentioned we initially also set out to investigate how useful PPDP
semantics are for debugging concurrent programs. As it stands, there are
two missing features

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Modifying concurrent control flow

  That is, a way to specify which thread will (try to) take a step
  forward next. The problem with concurrency is not so much technical:
  the primitives are available. What is needed is some way to step
  through a program one instruction at a time. The real challenge is
  providing a convenient mechanism for doing so.
\item
  Convenient user interface

  CaReDeb provides a command line interface. While CaReDeb is
  interesting from a technical point of view, its interface is not
  convenient. Additionally, the overhead of bringing the problem into
  CaReDeb's language is large: more time is probably spent translating
  than actually debugging.

  We think that a good graphical interface is possible, but besides
  technical features a good user experience also needs user feedback.
  This means that we need to look for users and concrete use cases. It
  would help if there were some concrete set of problems that could be
  extracted from code, compiled into a format/language that our debugger
  understands and then visually debugged. Performance can then be
  evaluated based on how well the debugger solves real-world problems.
\end{enumerate}

\section{Conclusion}\label{conclusion}

We have given an encoding of the PPDP'17 semantics in the Haskell
programming language. By embedding the semantics we can now run and
verify our example programs automatically and inspect them
interactively.

We have seen that the formal programming model in the PPDP'17 paper can
be split into three core components: a process calculus, multiparty
session types and reversibility. Additonally, all three of these are
representable as recursive Haskell data types. All other features of
PPDP'17 (the authors note decoupled rollbacks and abstraction passing,
including delegation) can easily be integrated when these three types
are established.

Relatedly, the implementation proces has shown that sticking to the
formal implementation leads to better code. There is less space for bugs
to creep in. Furthermore, Haskell's mathematical nature means that the
implementation inspired by the formal specification is easy (and often
idiomatic) to express.

We have seen that Haskell allows for the definition of flexible embedded
domain-specific languages, and makes it easy to transform between
different representations of our programs using among others
\texttt{Monad.Free}.

Finally, we have discussed how this implementation can be used for
concurrent debugging.\\
With more focus on the user experience, a solid concurrent debugging can
be built on the foundations presented here.

The work in this thesis has been presented at the TFP'18 conference in
Gothenburg, Sweden. Attending the conference was made possible by
financial support from the undergratudate school of science and the
Bernoulli Institute, for which we are extremely grateful.

\bibliographystyle{abbrv}
%\bibliography{biblio}
\bibliography{session,biblio}

\pagebreak
\appendix

\section{Appendix}\label{appendix}

Background information on Haskell syntax and concepts used in the
thesis.

\subsection{Installing and Running}\label{installing-and-running}

This project is written in Haskell and built with its \emph{stack} build
tool. Stack can be downloaded from
\href{https://docs.haskellstack.org/en/stable/README/}{here}. The next
step is to clone the repository, which is
\href{https://github.com/folkertdev/reversible-debugger}{available on
github}.

The snippet below will clone the repository (assumes ssh is set up) and
build it. This can take a while because it also has to download and
install the Haskell GHC compiler.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ clone git@github.com:folkertdev/reversible-debugger.git}
\BuiltInTok{cd}\NormalTok{ reversible-debugger}
\ExtensionTok{stack}\NormalTok{ build}
\end{Highlighting}
\end{Shaded}

Finally we can load an example program in the REPL:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{stack}\NormalTok{ ghci }\CommentTok{# opens the interactive environment}
\NormalTok{:}\ExtensionTok{l}\NormalTok{ src/Examples/ThreeBuyer.hs }\CommentTok{# loads the example}
\end{Highlighting}
\end{Shaded}

\subsection{Performing IO in Haskell}\label{performing-io}

One of Haskell's key characteristics is that it is pure. This means that
our computations cannot have any observable effect to the outside world.
Purity enables us to reason about our programs (referential
transparency) and enables compiler optimizations.

But we use computers to solve problems, and we want to be able to
observe the solution to our problems. Pure programs cannot produce
observable results: The computer becomes very hot but we cannot see our
solutions.

So we perform a trick: we say that constructing our program is
completely pure, but evaluating may produce side-effects like printing
to the console or writing to a file. To separate this possily effectful
code from pure code we use the type system: side-effects are wrapped in
the \texttt{IO} type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- print a string to the console}
\NormalTok{putStrLn}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}

\CommentTok{-- read a line of input from the console}
\NormalTok{readLn}\OtherTok{ ::} \DataTypeTok{IO} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

A consequence of having no observable effects is that the compiler can
reorder our code for faster execution (for instance by minimizing cache
misses). But this will wreak havoc when performing IO: we want our IO
actions to absolutely be ordered.

The trick we can pull here is to wrap the later actions in a function
taking one argument, and piping the result of the first action into that
function. The result is only available when the first action is done, so
the first action is always performed before the rest: we have
established a data-dependency between the first and the remaining
actions that enforces the order.

The piping is done by the \texttt{\textgreater{}\textgreater{}=}
operator. In the Haskell literature this function is refered to as
\texttt{bind}, but I think the elm name \texttt{andThen} is more
intuitive (at least for \texttt{IO}). A program that first reads a line
and then prints it again can be written as

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\FunctionTok{=} 
\NormalTok{    readLn }\FunctionTok{>>=}\NormalTok{ (\textbackslash{}line }\OtherTok{->}\NormalTok{ putStrLn line)}

\OtherTok{andThen ::} \DataTypeTok{IO}\NormalTok{ a }\OtherTok{->}\NormalTok{ (a }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ b) }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ b}
\NormalTok{andThen }\FunctionTok{=}\NormalTok{ (}\FunctionTok{>>=}\NormalTok{)}

\NormalTok{main2 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    readLn }\OtherTok{`andThen`}\NormalTok{ (\textbackslash{}line }\OtherTok{->}\NormalTok{ putStrLn line)}
\end{Highlighting}
\end{Shaded}

The \texttt{putStrLn} can only be evaluated when \texttt{line} is
available, so after \texttt{readLn} is done. More technically the
\texttt{(\textgreater{}\textgreater{}=)\ ::\ IO\ a\ -\textgreater{}\ (a\ -\textgreater{}\ IO\ b)\ -\textgreater{}\ IO\ b}
operator will first evaluate its first argument \texttt{IO\ a}, in this
case \texttt{IO\ String} (that string is the line we have read). Then it
``unwraps'' that \texttt{IO\ String} to \texttt{String} to give it as an
argument to \texttt{a\ -\textgreater{}\ IO\ b} (here
\texttt{String\ -\textgreater{}\ IO\ ()}). Note that we can never
(safely) go from \texttt{IO\ a\ -\textgreater{}\ a}. The unwrapping here
is only valid because the final return type is still
\texttt{IO\ something}.

When printing two lines, we can use a similar trick to force the order

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\FunctionTok{=} 
\NormalTok{    putStrLn }\StringTok{"hello "} \FunctionTok{>>=}\NormalTok{ (\textbackslash{}_ }\OtherTok{->}\NormalTok{ putStrLn }\StringTok{"world"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here we ignore the result of the first \texttt{putStrLn}, but the second
\texttt{putStrLn} still depends on its return value. Thus it has to wait
for the first \texttt{putStrLn} to finish before it can start.

\subsection{Do-notation}\label{do-notation}

Writing nested functions in this way quickly becomes tedious. That is
why special syntax is available: do-notation

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main1 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    line }\OtherTok{<-}\NormalTok{ readLn}
\NormalTok{    putStrLn line}

\NormalTok{main2 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    putStrLn }\StringTok{"hello "}
\NormalTok{    putStrLn }\StringTok{"world"}
\end{Highlighting}
\end{Shaded}

do-notation is only syntactic sugar: it is translated by the compiler to
the nested functions that we have seen above. The syntax is very
convenient however. Additionally, we can use it for all types that
implement \texttt{\textgreater{}\textgreater{}=}: all instances of the
\texttt{Monad} typeclass.

\subsection{Monads}\label{monads}

\texttt{Monad} is a Haskell typeclass (and a concept from a branch of
mathematics called category theory). Typeclasses are sets of types that
implement some functions, similar to interfaces or traits in other
languages.

The monad typeclass defines two methods:
bind/andThen/\texttt{\textgreater{}\textgreater{}=} which we have seen
and
\texttt{return\ ::\ Monad\ m\ =\textgreater{}\ a\ -\textgreater{}\ m\ a}.
The \texttt{Monad\ m\ =\textgreater{}} part of the signature constrains
the function to only work on types that have a \texttt{Monad} instance.

I hope the above already gives some intuition about monad's main
operator \texttt{\textgreater{}\textgreater{}=}: it forces order of
evaluation. A second property is that \texttt{Monad} can merge contexts
with
\texttt{join\ ::\ Monad\ m\ =\textgreater{}\ m\ (m\ a)\ -\textgreater{}\ m\ a}.
A common example of join is
\texttt{List.concat\ ::\ List\ (List\ a)\ -\textgreater{}\ List\ a}. A
bit more illustrative is the implementation for \texttt{Maybe}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{join ::} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a) }\OtherTok{->} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{join value }\FunctionTok{=} 
    \KeywordTok{case}\NormalTok{ value }\KeywordTok{of} 
        \DataTypeTok{Nothing} \OtherTok{->} 
            \DataTypeTok{Nothing}

        \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{Nothing}\NormalTok{) }\OtherTok{->} 
            \DataTypeTok{Nothing}

        \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{Just}\NormalTok{ x) }\OtherTok{->} 
            \DataTypeTok{Just}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

If the outer context has failed (is \texttt{Nothing}), then the total
computation has failed and there is no value of type \texttt{a} to give
back. If the outer computation succeeded but the inner one failed, there
is still no \texttt{a} and the only thing we can return is
\texttt{Nothing}. Only if both the inner and the outer computations have
succeeded can we give a result back.

In short:

\begin{itemize}
\tightlist
\item
  \texttt{Monad} is a Haskell typeclass
\item
  it has two main functions

  \begin{itemize}
  \tightlist
  \item
    bind or andThen or
    \texttt{\textgreater{}\textgreater{}=\ ::\ Monad\ m\ =\textgreater{}\ m\ a\ -\textgreater{}\ (a\ -\textgreater{}\ m\ b)\ -\textgreater{}\ m\ b}
  \item
    \texttt{return\ ::\ Monad\ m\ =\textgreater{}\ a\ -\textgreater{}\ m\ a}
  \end{itemize}
\item
  \texttt{Monad} forces the order of operations and can flatten wrappers
\item
  \texttt{Monad} allows us to use do-notation
\item
  \texttt{IO} is an instance of \texttt{Monad}
\end{itemize}

Much material on the web about monads is about establishing the general
idea, but really the exact meaning of
\texttt{\textgreater{}\textgreater{}=} can be very different for every
instance. Next we will look at some of the types used in the code for
this thesis.

\subsection{Except}\label{except}

Except is very similar to \texttt{Either}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Either}\NormalTok{ a b }
    \FunctionTok{=} \DataTypeTok{Left}\NormalTok{ a }
    \FunctionTok{|} \DataTypeTok{Right}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

We use this type to throw and track errors in a pure way.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{throwError ::}\NormalTok{ e }\OtherTok{->} \DataTypeTok{Except}\NormalTok{ e a}

\KeywordTok{data} \DataTypeTok{Error}
    \FunctionTok{=} \DataTypeTok{QueueEmpty}
    \FunctionTok{|} \FunctionTok{...}
    
\OtherTok{popQueue ::} \DataTypeTok{List}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Except} \DataTypeTok{Error}\NormalTok{ (a, }\DataTypeTok{List}\NormalTok{ a)}
\NormalTok{popQueue queue }\FunctionTok{=} 
    \KeywordTok{case}\NormalTok{ queue }\KeywordTok{of} 
\NormalTok{        [] }\OtherTok{->} 
\NormalTok{            Except.throwError }\DataTypeTok{QueueEmpty}

\NormalTok{        x }\FunctionTok{:}\NormalTok{ xs }\OtherTok{->} 
\NormalTok{            return ( x, xs )}
\end{Highlighting}
\end{Shaded}

Except and Either have a \texttt{Monad} instance. In this context
\texttt{return} means a non-error value, and
\texttt{\textgreater{}\textgreater{}=} allows us to chain multiple
operations that can fail, stopping when an error occurs.

\subsection{State and StateT}\label{state}

\texttt{State} is a wrapper around a function of type
\texttt{s\ -\textgreater{}\ (a,\ s)}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{State}\NormalTok{ s a }\FunctionTok{=} \DataTypeTok{State}\NormalTok{ \{}\OtherTok{ unState ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ (a, s) \} }
\end{Highlighting}
\end{Shaded}

It is used to give the illusion of mutible state, while remaining
completely pure. Intuitively, we can compose functions of this kind.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{f ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ (a,   s)}
\OtherTok{g ::}\NormalTok{       a }\OtherTok{->}\NormalTok{ s }\OtherTok{->}\NormalTok{ (b, s)}
\CommentTok{-- implies}
\OtherTok{h ::}\NormalTok{ s }\OtherTok{->}\NormalTok{            (b, s)}
\end{Highlighting}
\end{Shaded}

And this is exactly what monadic bind for state does.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{andThen ::} \DataTypeTok{State}\NormalTok{ s a }\OtherTok{->}\NormalTok{ (a }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s b) }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s b}
\NormalTok{andThen (}\DataTypeTok{State}\NormalTok{ first) tagger }\FunctionTok{=} 
    \DataTypeTok{State} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->} 
        \KeywordTok{let}\NormalTok{ (value, newState) }\FunctionTok{=}\NormalTok{ first s}
            \DataTypeTok{State}\NormalTok{ second }\FunctionTok{=}\NormalTok{ tagger value}
        \KeywordTok{in}
\NormalTok{            second newState }

\OtherTok{new ::}\NormalTok{ a }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s a}
\NormalTok{new value }\FunctionTok{=} \DataTypeTok{State}\NormalTok{ (\textbackslash{}s }\OtherTok{->}\NormalTok{ (value, s))}

\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ s) }\KeywordTok{where}
\NormalTok{    (}\FunctionTok{>>=}\NormalTok{) }\FunctionTok{=}\NormalTok{ andThen}
\NormalTok{    return }\FunctionTok{=}\NormalTok{ new}
\end{Highlighting}
\end{Shaded}

When we want to combine monads, for instance to have both state and
error reporting, we must use monad transformers. The transformer is
needed because monads do not naturally combine: \texttt{m1\ (m2\ a)} may
not have a law-abiding monad instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{StateT}\NormalTok{ s m a }\FunctionTok{=} \DataTypeTok{StateT}\NormalTok{ \{}\OtherTok{ runStateT ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ m (a, s) \}  }

\KeywordTok{instance} \DataTypeTok{MonadTrans}\NormalTok{ (}\DataTypeTok{StateT}\NormalTok{ s) }\KeywordTok{where} 
\OtherTok{    lift ::}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ m) }\OtherTok{=>}\NormalTok{ m a }\OtherTok{->} \DataTypeTok{StateT}\NormalTok{ s m a}
\NormalTok{    lift m }\FunctionTok{=} \DataTypeTok{StateT} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->} \KeywordTok{do}
\NormalTok{        a }\OtherTok{<-}\NormalTok{ m}
\NormalTok{        return (a, s)}

\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ m) }\OtherTok{=>} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{StateT}\NormalTok{ s m) }\KeywordTok{where}
\NormalTok{    return a }\FunctionTok{=} \DataTypeTok{StateT} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->}\NormalTok{ return (a, s)}
\end{Highlighting}
\end{Shaded}

The \texttt{MonadTrans} typeclass defines the \texttt{lift} function
that wraps a monadic value into the transformer. Next we define an
instance because we can say \emph{given a monad \texttt{m},
\texttt{StateT\ s\ m} is a law-abiding monad}.

\subsection{Factoring out recursion}\label{factoring-recursion}

A commonly used idiom in our code is to factor out recursion from a data
structure, using the \texttt{Fix} and \texttt{Monad.Free} types. Both
require the data type to be an instance of \texttt{Functor}: The type is
of the shape \texttt{f\ a} - like \texttt{List\ a} or \texttt{Maybe\ a},
and there exists a mapping function
\texttt{fmap\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ (f\ a\ -\textgreater{}\ f\ b)}.

Fix requires the data type to have a natural leaf: a constructor that
does not contain an \texttt{a}. \texttt{Free} on the other hand lets us
choose some other type for the leaves.

\subsection{Fix}\label{fix}

The \texttt{Fix} data type is the fixed point type.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Fix}\NormalTok{ f }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (f (}\DataTypeTok{Fix}\NormalTok{ f))}
\end{Highlighting}
\end{Shaded}

It allows us to express a type of the shape
\texttt{f\ (f\ (f\ (f\ (..))))} concisely. For the values of this type
to be finite, the \texttt{f} must have a constructor that does not
recurse to be a leaf. Take for instance this simple expression language

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Expr}
    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{Add} \DataTypeTok{Expr} \DataTypeTok{Expr} 
\end{Highlighting}
\end{Shaded}

\texttt{Literal} is the only constructor that can occur as a leaf, and
\texttt{Add} is the only node. Using \texttt{Fix} we can equivalently
write

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ExprF}\NormalTok{ next}
    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{Add}\NormalTok{ next next }
\end{Highlighting}
\end{Shaded}

Defining values of type \texttt{Fix\ ExprF} requires wrapping of
constructors with \texttt{Fix}. We will describe a better way of writing
\texttt{Fix}ed values in Section \ref{free-monad-dsl}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{simple ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
\NormalTok{simple }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{42}\NormalTok{)}

\OtherTok{complex ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
\NormalTok{complex }\FunctionTok{=} 
    \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Add}\NormalTok{ (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{40}\NormalTok{)) (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{2}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

By decoupling the recursion from the content, we can write functions
that deal with only one level of the tree and apply them to the full
tree. For instance evaluation of the above expression can be written as

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{evaluate ::} \DataTypeTok{Fix} \DataTypeTok{ExprF} \OtherTok{->} \DataTypeTok{Int} 
\NormalTok{evaluate }\FunctionTok{=} 
\NormalTok{    Fix.cata }\FunctionTok{$}\NormalTok{ \textbackslash{}expr }\OtherTok{->} 
        \KeywordTok{case}\NormalTok{ expr }\KeywordTok{of} 
            \DataTypeTok{Literal}\NormalTok{ v }\OtherTok{->} 
\NormalTok{                v}

            \DataTypeTok{Add}\NormalTok{ a b }\OtherTok{->} 
\NormalTok{                a }\FunctionTok{+}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

The \texttt{cata} function - a catamorphism also known as a fold or
reduce - applies evaluate from the bottom up. In the code we write, we
only need to make local decisions and don't have to write the plumbing
to get the recursion right.

\subsection{Monad.Free}\label{free-monad}

The Free monad is very similar to \texttt{Fix}, but allows us to use a
different type for the leaves, and enables us to use do-notation.
Writing expressions with \texttt{Fix} can be quite messy, free monads
allow us to write examples much more succinctly.

Free is defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Free}\NormalTok{ f a}
    \FunctionTok{=} \DataTypeTok{Pure}\NormalTok{ a }
    \FunctionTok{|} \DataTypeTok{Free}\NormalTok{ (f (}\DataTypeTok{Free}\NormalTok{ f a))}
\end{Highlighting}
\end{Shaded}

and as the name suggests \texttt{Monad.Free} has a Monad instance.

This then makes it possible to define a functor that represents
instructions, define some helpers and then use do-notation to write our
actual programs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{StackF}\NormalTok{ a next }
    \FunctionTok{=} \DataTypeTok{Push}\NormalTok{ a next}
    \FunctionTok{|} \DataTypeTok{Pop}\NormalTok{ (a }\OtherTok{->}\NormalTok{ next)}
    \FunctionTok{|} \DataTypeTok{End} 
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{)}

\KeywordTok{type} \DataTypeTok{Stack}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Free} \DataTypeTok{StackF}\NormalTok{ a}
     
\OtherTok{program ::} \DataTypeTok{Stack} \DataTypeTok{Int}
\NormalTok{program }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    push }\DecValTok{5} 
\NormalTok{    push }\DecValTok{4} 
\NormalTok{    a }\OtherTok{<-}\NormalTok{ pop}
\NormalTok{    b }\OtherTok{<-}\NormalTok{ pop}
\NormalTok{    push (a }\FunctionTok{+}\NormalTok{ b)}

\OtherTok{push ::}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Stack}\NormalTok{ a ()}
\NormalTok{push v }\FunctionTok{=}\NormalTok{ liftFree (}\DataTypeTok{Push}\NormalTok{ v ()) }

\OtherTok{pop ::} \DataTypeTok{Stack}\NormalTok{ a a }
\NormalTok{pop }\FunctionTok{=}\NormalTok{ liftFree (}\DataTypeTok{Pop}\NormalTok{ identity)}
\end{Highlighting}
\end{Shaded}

\subsection{Guaranteeing well-formedness of
Free}\label{well-formedness-free}

We use the free monad to build up programs and global types. A problem
with the free monad is that the built-up tree can still contain
``holes'' because of the \texttt{Pure\ \_} branch of \texttt{Free}. That
is fine while constructing the tree, but when evaluating it we want all
\texttt{Pure}s to be gone. There are two ways of enforcing this
constraint using the type systems.

We observe that only our leaves have a free type variable. For instance
for \texttt{HighLevelProgram}, only \texttt{terminate} (via NoOp) can
have type \texttt{HighLevelProgram\ a} where the \texttt{a} is unbound.
That means that \texttt{terminate} will unify with anything:
\texttt{HighLevelProgram\ String}, \texttt{HighLevelProgram\ Int}, etc.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{terminate ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{terminate }\FunctionTok{=} \DataTypeTok{HighLevelProgram}\NormalTok{ (liftF }\DataTypeTok{NoOp}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There are now two ways forward:

\textbf{Solution 1: Rank2Types and Universal Quantification}

Now if we enforce that our whole program unifies with anything, that
implies that all \texttt{Pure}s are gone from the structure. Normally,
type signatures are valid if there is at least one valid unification for
every type variable (i.e.~existential quantification). But with the
language extension \texttt{ExplicitForAll} we can mark type variables as
universally quantified: they need to unify with all types. In this case
we also need \texttt{Rank2Types} because of the position where we want
to use \texttt{forall}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{-# LANGUAGE Rank2Types #-\}}
\OtherTok{\{-# LANGUAGE ExplicitForAll #-\}}

\OtherTok{compile ::} \DataTypeTok{Participant} \OtherTok{->}\NormalTok{ (forall a}\FunctionTok{.} \DataTypeTok{HighLevelProgram}\NormalTok{ a) }\OtherTok{->} \DataTypeTok{Program} \DataTypeTok{Value}
\NormalTok{compile participant (}\DataTypeTok{HighLevelProgram}\NormalTok{ program) }\FunctionTok{=} \FunctionTok{...}
\end{Highlighting}
\end{Shaded}

\textbf{Solution 2: Data.Void}

The second solution is to use \texttt{Data.Void}. \texttt{Void} is the
data type with zero values, which means there is no valid way of
creating a value of type \texttt{Void}. Thus a \texttt{Free\ f\ Void}
cannot have any \texttt{Pure}s, because they need a value of type
\texttt{Void} and there are none.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import }\DataTypeTok{Data.Void}\NormalTok{ (}\DataTypeTok{Void}\NormalTok{)}

\OtherTok{compile ::} \DataTypeTok{Participant} \OtherTok{->} \DataTypeTok{HighLevelProgram} \DataTypeTok{Void} \OtherTok{->} \DataTypeTok{Program} \DataTypeTok{Value}
\NormalTok{compile participant (}\DataTypeTok{HighLevelProgram}\NormalTok{ program) }\FunctionTok{=} \FunctionTok{...}
\end{Highlighting}
\end{Shaded}

\textbf{Tradeoffs}

In the codebase we went with solution 2 because it produces clearer
error messages and does not introduce extra language extensions to the
project.

\subsection{Scheduling code}\label{scheduling-code}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Progress} \FunctionTok{=} \DataTypeTok{Progress} \FunctionTok{|} \DataTypeTok{NoProgress} \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Show}\NormalTok{)}

\NormalTok{round}\OtherTok{ ::} \DataTypeTok{List} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{ExecutionState} \DataTypeTok{Value} 
      \OtherTok{->} \DataTypeTok{Either} \DataTypeTok{Error}\NormalTok{ ( }\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{)}
\NormalTok{                      , }\DataTypeTok{ExecutionState} \DataTypeTok{Value}
\NormalTok{                      )}
\NormalTok{round locations state }\FunctionTok{=} 
\NormalTok{    foldM helper [] locations }
        \FunctionTok{|>}\NormalTok{ flip State.runStateT state}
        \FunctionTok{|>}\NormalTok{ Except.runExcept}
  \KeywordTok{where}\OtherTok{ helper ::} \DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{) }\OtherTok{->} \DataTypeTok{Location} 
               \OtherTok{->} \DataTypeTok{Session} \DataTypeTok{Value}\NormalTok{ (}\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{))}
\NormalTok{        helper accum location }\FunctionTok{=} \KeywordTok{do}
\NormalTok{            state }\OtherTok{<-}\NormalTok{ State.get}

            \KeywordTok{let}\NormalTok{ evaluated }\FunctionTok{=} 
\NormalTok{                    State.runStateT (forward location) state }
                        \FunctionTok{|>}\NormalTok{ Except.runExcept }

            \KeywordTok{case}\NormalTok{ evaluated }\KeywordTok{of}
                \DataTypeTok{Right}\NormalTok{ ( _, s ) }\OtherTok{->} \KeywordTok{do}
\NormalTok{                    State.put s}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{Progress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{QueueError}\NormalTok{ origin (}\DataTypeTok{InvalidQueueItem}\NormalTok{ message)) }\OtherTok{->} 
                    \CommentTok{-- blocked on receive, try moving others forward}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{NoProgress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{QueueError}\NormalTok{ origin }\DataTypeTok{EmptyQueue}\NormalTok{) }\OtherTok{->} 
                    \CommentTok{-- blocked on receive, try moving others forward}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{NoProgress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left} \DataTypeTok{Terminated} \OtherTok{->} 
\NormalTok{                    return accum}
                            
                \DataTypeTok{Left}\NormalTok{ err }\OtherTok{->} 
                    \CommentTok{-- other errors are raised}
\NormalTok{                    Except.throwError err}


\OtherTok{untilError ::} \DataTypeTok{ExecutionState} \DataTypeTok{Value} 
           \OtherTok{->} \DataTypeTok{Either} \DataTypeTok{Error}\NormalTok{ (}\DataTypeTok{ExecutionState} \DataTypeTok{Value}\NormalTok{)}
\NormalTok{untilError state}\FunctionTok{@}\DataTypeTok{ExecutionState}\NormalTok{\{ locations \} }\FunctionTok{=} 
\NormalTok{    helper (Map.keys locations) state}
  \KeywordTok{where}\NormalTok{ helper locations state }\FunctionTok{=} \KeywordTok{do}
\NormalTok{            ( locationProgress, newState ) }\OtherTok{<-} 
\NormalTok{                Interpreter.round locations state}

            \KeywordTok{let}\NormalTok{ isProgress }\FunctionTok{=}  
\NormalTok{                    any }
\NormalTok{                        (\textbackslash{}(_, progress) }\OtherTok{->}\NormalTok{ progress }\FunctionTok{==} \DataTypeTok{Progress}\NormalTok{) }
\NormalTok{                        locationProgress }

            \KeywordTok{if}\NormalTok{ null locationProgress }\KeywordTok{then} 
                \CommentTok{-- no active locations}
                \DataTypeTok{Right}\NormalTok{ state}

            \KeywordTok{else} \KeywordTok{if}\NormalTok{ isProgress }\KeywordTok{then} 
\NormalTok{                helper (List.map fst locationProgress) newState}

            \KeywordTok{else}
\NormalTok{                error }\FunctionTok{$} \StringTok{"DEADLOCK\textbackslash{}n"} \FunctionTok{++}\NormalTok{ show state}
\end{Highlighting}
\end{Shaded}

\end{document}


