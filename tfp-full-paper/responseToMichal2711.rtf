{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\froman\fcharset0 Times-Roman;\f2\fnil\fcharset0 AppleSymbols;
\f3\fnil\fcharset0 ArialUnicodeMS;}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;\red0\green0\blue255;\red0\green0\blue255;
}
{\*\expandedcolortbl;;\csgenericrgb\c10196\c10196\c10196;\csgenericrgb\c0\c0\c100000;\cssrgb\c1680\c19835\c100000;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\
On Tue, Nov 27, 2018 at 12:16 PM Michal Palka <michal.palka@chalmers.se> wrote:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Dear Jorge and Folkert,
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Here are my comments to your latest draft. I found the new draft to be much better than the submitted version.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> 1. Overall, I believe that significant focus should be put on linking the implementation to the formalism you developed previously (and pointing out where they differ). Similarly to the reviewers, I would like to request more explicit links between these two.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
To address this, we have expanded the number of references from the content in Section 3 to the (new) subsections of Section 2.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 2. I am an outsider to process calculi and session types. Some of my comments may seem naive, but might still be useful as many of the readers might not be familiar with the areas either.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
OK.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 3. My understanding of the paper increases every time I read it, and I might find more points to address as I read it again.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
OK.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 4. I will now go through all the points I would like to raise in the order they appear in the paper.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
OK.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 5. Page 3: l_i and P_i should be l_j and P_j
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Actually, they are fine as they are; we have clarified that I_j is one of the possible labels (and similarly for P_j).
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> 6. Page 3: For completeness it would be good to also explain the 'u,w ::= \'85\'92 construction.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Done.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> 7. Page 4: As Reviewer 2 noted:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > It's confusing to first introduce parallel composition with syntax "|" and then use "|" as the symbol to separate different syntactic options
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> It would be good to use a different symbol, or somehow highlight the syntactic similarity in the text.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Well, they are already different symbols: the bnf bar is larger/thicker than the parallel composition operator.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 8. Page 4:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > We write (\'85) to denote a message queue with input part hi and output part ho
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> while reference 6 contains a much more complete description:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Following [14], we have message queues of the form s : (hi 
\f2 \uc0\u8902 
\f0 ho), where s is a session, hi is the input part of the queue, and ho is the output part of the queue. Each queue contains messages of the form(p , q , m) (read: \'93message m is sent from p to q\'94). As we will see, the effect of an output prefix ina process is to place the message in its corresponding output queue; conversely, the effect of an inputprefix is to obtain the first message from its input queue. Messages in the queue are never consumed:a process reads a message (p, q, m) by moving it from the (tail of) queue ho to the (top of) queue hi.This way, the delimiter \'91
\f2 \uc0\u8902 
\f0 \'92 distinguishes the past of the queue from its future.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Having at least one sentence explaining that the output queue contains \'91consumed\'92 messages would be very helpful. In fact, I initially incorrectly assumed that it is h_o that contains the \'91consumed\'92 messages.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Done: we have added a sentence here.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 9. Page 4:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Finally, the running function k
\f3 \uc0\u8970 
\f0 (V u) , l
\f3 \uc0\u8971 
\f0  serves to reverse applications.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> This sentence does not explain much, so I looked at the rest of the paper for clues. The 'Function calls and their arguments\'92 paragraph on page 16 (which links back to page 8) seems to explain it, but is very difficult to follow. The syntax k
\f3 \uc0\u8970 
\f0 (V u) , l
\f3 \uc0\u8971 
\f0  appears in M_9 (not M_8), which is not even mentioned on page 16. Both 'the thunk\'92 and the instance of  k
\f3 \uc0\u8970 
\f0 (V u) , l
\f3 \uc0\u8971 
\f0  should be explicitly referenced on page 16. After reading it many times through I guessed that \'91the thunk\'92 refers to \'91code *\'92. In general, the lack of concrete links like this between different parts of the paper seems to be a major problem in this draft. Inserting a forward reference from page 4 to page 16 might also be a good idea.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
We have extended the description of running functions.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 10. Page 5:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > The definition is intuitive, perhaps except for choice. Intuitively, the definition ensures that a choice between p and q should not implicitly determine different behavior for participants different from p and q, for which different behavior should be determined by some explicit communication.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> A language nitpick: it is a bit unfortunate to say that the definition of choice is not \'91intuitive\'92, but then refer to the intuition behind it in the following sentence.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
We have rephrased this.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 11. Page 5:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Intuitively, the definition ensures that a choice between p and q should not implicitly determine different behavior for participants different from p and q, for which different behavior should be determined by some explicit communication. This is a condition adopted by the MP model but also by several other works, as it ensures decentralized implementability of multiparty session types. Because of recursion, a branch of a choice may recurse back to the beginning: in this case all participants have to jump back to the beginning, so every choice must be explicit to all participants. Our Haskell implementation relies on broadcasts to communicate choices to all protocol participants; this reduces the need for explicit communications in global types.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Without further explanation, the second part of the paragraph seems to contradict the first part. On the one hand, participants different than p and q should not be influenced by choices made between p and q, but on the other hand if one branch recurses to the beginning, everyone must jump back. If this is the case, the paragraph should make the contrast explicit (and somehow resolve the apparent contradiction).
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> In fact, the corresponding paragraph in the original draft is not self-contradictory. Reviewer 2 requested explaining the sentence on the differences between the implementation and the formalism. I would recommend reverting back to the original paragraph, and trying to address the comment of Reviewer 2. The new paragraph seems to convey the wrong message.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
We reworked this, to separate the messages:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf3 \expnd0\expndtw0\kerning0
1- the fact that projection ensures that choices can be implemented in a decentralized way
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf3 \expnd0\expndtw0\kerning0
2- the interplay between recursion and choices
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf3 \expnd0\expndtw0\kerning0
The explanations concerning "explicit communications" concern 1, not 2.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 12. Page 6: Please address this comment of Reviewer 2:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Do not use numeric citations as part of sentences. Don't say "as in [6]\'94. Sentences should remain grammatically correct if the numbers are removed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 13. Page 6:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > From M, the session starts with a forward reduction
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> It would be good to refer to a concrete page number in the referenced paper, and the rule name, for the first reduction.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have referred to the section in [6].
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 14. Page 6: The syntax 'A1\{s[A]/y\}\'92 doesn\'92t seem to be explained anywhere.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 15. I have not managed to check all the syntax of the example starting on page 6.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
We have revised all the example, adding clarifications where appropriate.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 16: Page 9: Using 'deriving (Functor)' requires DeriveFunctor or possibly another GHC extension. Please mention it.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have added a sentence.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 17: Page 9:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > type TerminatingProgram = Free Program Void
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> I would suggest using 'type TerminatingProgram = Program Void\'92 instead making it explicit that 'TerminatingProgram' is an instance of 'Program a\'92. This also applies to the definition of 'TerminatingGlobalType' on page 13.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 18: Page 9: It would be good to include some intuition about the Free monad before the paragraph starting with 'The Free functor defines a Pure case that we don\'92t need.\'92. An intuition I find useful is that a value of type Free Operation a is an incomplete program with placeholder values of type a in place of some of the continuations (the next type parameter of the functor is the type of the continuation). Composition then puts other (possibly incomplete) programs into the placeholders.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have elaborated on this.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 19: Page 9:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > The Free functor defines a Pure case that we don\'92t need
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> I would argue that you do need the Pure case, as you are using it for composition. Although closed programs (TerminatingProgram) indeed do not contain it.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 20: Page 9:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > The use of Void also gives some indication that theprogram is finite.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> This statement concerns me, because:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> * In principle you may construct and infinite term using Haskell\'92s unbound recursion.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> * Your language has explicit recursion anyway.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> I would recommend making the statement more qualified.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have rephrased this sentence/paragraph.\
\pard\pardeftab720\partightenfactor0
\cf2 \
> 21: Page 10: liftF is not defined anywhere. Please at least show its type and explain what it does. I found it a bit tricky to understand what liftF does for the StateT transformer.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have added an explanation for liftF.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 22: Page 11: It is puzzling for me why the Value type has so many constructors. I would like to understand what they correspond to in the formalism.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed. Actually this was already explained (we have additional constructs to write more interesting examples) but we have elaborated a little.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 23: Page 12:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Because we allow references to values in the implementation, all references ina function have to be dereferenced before they can be safely sent over a channel.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> I don\'92t see any mention of references in the formalism, so this must be one of the differences between the formalism and the implementation? If yes, it should be clearly explained.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf4 \expnd0\expndtw0\kerning0
Fixed: we have rephrased this sentence. 
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 24: Page 14: The code refers to the \'91R\'92, \'91Wk\'92 and \'91V\'92 constructors, which should probably be \'91RecursionPoint\'92, \'91WeakenRecursion\'92 and \'91RecursionVariable\'92 instead.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 25: What about projections from global types to local types? The code later one refers to the type LocalType, which suggests that the projection is implemented. It should at least be mentioned for completeness.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf4 \expnd0\expndtw0\kerning0
Fixed: we now stress that projection is implemented as in Section 2.4.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 26: It is not clear what kind of type safety is provided by either of the formalism and the implementation. It would be good if some statement about this were included. See also this comment by Reviewer 1 to the original draft:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > In the discussion, it is mentioned that \'93the type system can actually guarantee that we have not forgotten to revert anything\'94. Is this really true? If so, it is an interesting point which deserves a lot more illustration.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
The formal model concerns untyped processes, and so there is no type safety property. The semantics of these untyped processes is governed by local session types; for this semantics, causal consistency is the main property of interest. We have clarified this in Sect 3.6.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> 27: Page 16:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Recall the process implementation for thevendor in the three-buyer example
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Please include a page reference.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we included a section reference.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 28: Page 17:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > follows closely follows
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Pick one.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 29: Page 17: Please provide the definition or explanation of Except.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have added a short explanation.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 30: Page 21:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Note that this scheduler can still get into deadlocks
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> Is this a property of this particular scheduler, or of the whole formalism? Is there a better scheduler that would avoid such deadlocks?
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed: we have elaborated a bit on the fundamental issue here.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 31: Page 21:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > B expects the share from V first
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> V sends the message \'91Price\'92 to B in this example, not \'91Share\'92.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 32: Page 21: GlobalTypeF uses the \'91R\'92, \'91Wk\'92 and \'91V\'92 constructors, which don\'92t match the previous definition.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf2 \expnd0\expndtw0\kerning0
\
> 33: Page 22: Please address this comment of Reviewer 2:
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
> > Page 20: "The definitions correspond directly". Somewhat ironically, you're choosing an example where they don't, because you're using a de-Bruijn encoding to avoid variable names, which means that "V" and "Wk\'94 both correspond to the variable case.
\f1 \cf0 \kerning1\expnd0\expndtw0 \

\f0 \cf2 \expnd0\expndtw0\kerning0
>
\f1 \cf0 \kerning1\expnd0\expndtw0 \
\pard\pardeftab720\partightenfactor0

\f0 \cf3 \expnd0\expndtw0\kerning0
Fixed.}