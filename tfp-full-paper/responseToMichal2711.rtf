{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fnil\fcharset0 AppleSymbols;\f2\fnil\fcharset0 ArialUnicodeMS;
}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;\red255\green255\blue255;\red251\green2\blue7;
\red0\green0\blue255;\red0\green0\blue255;\red251\green2\blue7;}
{\*\expandedcolortbl;;\cssrgb\c13333\c13333\c13333;\cssrgb\c100000\c100000\c100000;\cssrgb\c100000\c14913\c0;
\cssrgb\c1680\c19835\c100000;\cssrgb\c1680\c19835\c100000;\cssrgb\c100000\c14913\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11180\viewh17780\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 On Tue, Nov 27, 2018 at 12:16 PM Michal Palka <michal.palka@chalmers.se> wrote:\cb1 \
\cb3 >\cb1 \
\cb3 > Dear Jorge and Folkert,\cb1 \
\cb3 >\cb1 \
\cb3 > Here are my comments to your latest draft. I found the new draft to be much better than the submitted version.\cb1 \
\cb3 >\cb1 \
\cb3 > 1. Overall, I believe that significant focus should be put on linking the implementation to the formalism you developed previously (and pointing out where they differ). Similarly to the reviewers, I would like to request more explicit links between these two.\cb1 \
\cb3 >\cb1 \
\cf4 \cb3 To be done.\cf2 \cb1 \
\
\cb3 > 2. I am an outsider to process calculi and session types. Some of my comments may seem naive, but might still be useful as many of the readers might not be familiar with the areas either.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 OK.\cf2 \cb1 \
\
\cb3 > 3. My understanding of the paper increases every time I read it, and I might find more points to address as I read it again.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 OK.\cf2 \cb1 \
\
\cb3 > 4. I will now go through all the points I would like to raise in the order they appear in the paper.\cb1 \
\cf5 \cb3 OK.\cf2 \cb1 \
\
\cb3 > 5. Page 3: l_i and P_i should be l_j and P_j\cb1 \
\cf5 \cb3 Actually, they are fine as they are; we have clarified that I_j is one of the possible labels (and similarly for P_j).\cf2 \cb1 \
\
\cb3 >\cb1 \
\cb3 > 6. Page 3: For completeness it would be good to also explain the 'u,w ::= \'85\'92 construction.\cb1 \
\cf5 \cb3 Done.\cf2 \cb1 \
\
\cb3 >\cb1 \
\cb3 > 7. Page 4: As Reviewer 2 noted:\cb1 \
\cb3 > > It's confusing to first introduce parallel composition with syntax "|" and then use "|" as the symbol to separate different syntactic options\cb1 \
\cb3 >\cb1 \
\cb3 > It would be good to use a different symbol, or somehow highlight the syntactic similarity in the text.\cb1 \
\cf5 \cb3 Well, they are already different symbols: the bnf bar is larger/thicker than the parallel composition operator.\cf2 \cb1 \
\
\cb3 > 8. Page 4:\cb1 \
\cb3 > > We write (\'85) to denote a message queue with input part hi and output part ho\cb1 \
\cb3 > while reference 6 contains a much more complete description:\cb1 \
\cb3 > > Following [14], we have message queues of the form s : (hi 
\f1 \uc0\u8902 
\f0 ho), where s is a session, hi is the input part of the queue, and ho is the output part of the queue. Each queue contains messages of the form(p , q , m) (read: \'93message m is sent from p to q\'94). As we will see, the effect of an output prefix ina process is to place the message in its corresponding output queue; conversely, the effect of an inputprefix is to obtain the first message from its input queue. Messages in the queue are never consumed:a process reads a message (p, q, m) by moving it from the (tail of) queue ho to the (top of) queue hi.This way, the delimiter \'91
\f1 \uc0\u8902 
\f0 \'92 distinguishes the past of the queue from its future.\cb1 \
\cb3 >\cb1 \
\cb3 > Having at least one sentence explaining that the output queue contains \'91consumed\'92 messages would be very helpful. In fact, I initially incorrectly assumed that it is h_o that contains the \'91consumed\'92 messages.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 Done: we have added a sentence here.\cf2 \cb1 \
\
\cb3 > 9. Page 4:\cb1 \
\cb3 > > Finally, the running function k
\f2 \uc0\u8970 
\f0 (V u) , l
\f2 \uc0\u8971 
\f0  serves to reverse applications.\cb1 \
\cb3 >\cb1 \
\cb3 > This sentence does not explain much, so I looked at the rest of the paper for clues. The 'Function calls and their arguments\'92 paragraph on page 16 (which links back to page 8) seems to explain it, but is very difficult to follow. The syntax k
\f2 \uc0\u8970 
\f0 (V u) , l
\f2 \uc0\u8971 
\f0  appears in M_9 (not M_8), which is not even mentioned on page 16. Both 'the thunk\'92 and the instance of  k
\f2 \uc0\u8970 
\f0 (V u) , l
\f2 \uc0\u8971 
\f0  should be explicitly referenced on page 16. After reading it many times through I guessed that \'91the thunk\'92 refers to \'91code *\'92. In general, the lack of concrete links like this between different parts of the paper seems to be a major problem in this draft. Inserting a forward reference from page 4 to page 16 might also be a good idea.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 We have extended the description of running functions.\cf2 \cb1 \
\
\cb3 > 10. Page 5:\cb1 \
\cb3 > > The definition is intuitive, perhaps except for choice. Intuitively, the definition ensures that a choice between p and q should not implicitly determine different behavior for participants different from p and q, for which different behavior should be determined by some explicit communication.\cb1 \
\cb3 >\cb1 \
\cb3 > A language nitpick: it is a bit unfortunate to say that the definition of choice is not \'91intuitive\'92, but then refer to the intuition behind it in the following sentence.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 We have rephrased this.\cf2 \cb1 \
\
\cb3 > 11. Page 5:\cb1 \
\cb3 > > Intuitively, the definition ensures that a choice between p and q should not implicitly determine different behavior for participants different from p and q, for which different behavior should be determined by some explicit communication. This is a condition adopted by the MP model but also by several other works, as it ensures decentralized implementability of multiparty session types. Because of recursion, a branch of a choice may recurse back to the beginning: in this case all participants have to jump back to the beginning, so every choice must be explicit to all participants. Our Haskell implementation relies on broadcasts to communicate choices to all protocol participants; this reduces the need for explicit communications in global types.\cb1 \
\cb3 >\cb1 \
\cb3 > Without further explanation, the second part of the paragraph seems to contradict the first part. On the one hand, participants different than p and q should not be influenced by choices made between p and q, but on the other hand if one branch recurses to the beginning, everyone must jump back. If this is the case, the paragraph should make the contrast explicit (and somehow resolve the apparent contradiction).\cb1 \
\cb3 >\cb1 \
\cb3 > In fact, the corresponding paragraph in the original draft is not self-contradictory. Reviewer 2 requested explaining the sentence on the differences between the implementation and the formalism. I would recommend reverting back to the original paragraph, and trying to address the comment of Reviewer 2. The new paragraph seems to convey the wrong message.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 We reworked this, to separate the messages:\cb1 \
\cb3 1- the fact that projection ensures that choices can be implemented in a decentralized way\cb1 \
\cb3 2- the interplay between recursion and choices\cb1 \
\cb3 The explanations concerning "explicit communications" concern 1, not 2.\cf2 \cb1 \
\
\cb3 > 12. Page 6: Please address this comment of Reviewer 2:\cb1 \
\cb3 > > Do not use numeric citations as part of sentences. Don't say "as in [6]\'94. Sentences should remain grammatically correct if the numbers are removed.\cb1 \
\cb3 >\cb1 \
\cf5 \cb3 Fixed.\cf2 \cb1 \
\
\cb3 > 13. Page 6:\cb1 \
\cb3 > > From M, the session starts with a forward reduction\cb1 \
\cb3 >\cb1 \
\cb3 > It would be good to refer to a concrete page number in the referenced paper, and the rule name, for the first reduction.\cb1 \
\cb3 >\
\cf5 Fixed: we have referred to the section in [6].\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 14. Page 6: The syntax 'A1\{s[A]/y\}\'92 doesn\'92t seem to be explained anywhere.\cb1 \
\cb3 >\
\cf5 Fixed.\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 15. I have not managed to check all the syntax of the example starting on page 6.\cb1 \
\cb3 >\
\cf6 We have revised all the example, adding clarifications where appropriate.\cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 16: Page 9: Using 'deriving (Functor)' requires DeriveFunctor or possibly another GHC extension. Please mention it.\cb1 \
\cb3 >\
\cf4 FOLKERT?\cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 17: Page 9:\cb1 \
\cb3 > > type TerminatingProgram = Free Program Void\cb1 \
\cb3 > I would suggest using 'type TerminatingProgram = Program Void\'92 instead making it explicit that 'TerminatingProgram' is an instance of 'Program a\'92. This also applies to the definition of 'TerminatingGlobalType' on page 13.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 18: Page 9: It would be good to include some intuition about the Free monad before the paragraph starting with 'The Free functor defines a Pure case that we don\'92t need.\'92. An intuition I find useful is that a value of type Free Operation a is an incomplete program with placeholder values of type a in place of some of the continuations (the next type parameter of the functor is the type of the continuation). Composition then puts other (possibly incomplete) programs into the placeholders.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 19: Page 9:\cb1 \
\cb3 > > The Free functor defines a Pure case that we don\'92t need\cb1 \
\cb3 > I would argue that you do need the Pure case, as you are using it for composition. Although closed programs (TerminatingProgram) indeed do not contain it.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 20: Page 9:\cb1 \
\cb3 > > The use of Void also gives some indication that theprogram is finite.\cb1 \
\cb3 >\cb1 \
\cb3 > This statement concerns me, because:\cb1 \
\cb3 > * In principle you may construct and infinite term using Haskell\'92s unbound recursion.\cb1 \
\cb3 > * Your language has explicit recursion anyway.\cb1 \
\cb3 > I would recommend making the statement more qualified.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 21: Page 10: liftF is not defined anywhere. Please at least show its type and explain what it does. I found it a bit tricky to understand what liftF does for the StateT transformer.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 22: Page 11: It is puzzling for me why the Value type has so many constructors. I would like to understand what they correspond to in the formalism.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 23: Page 12:\cb1 \
\cb3 > > Because we allow references to values in the implementation, all references ina function have to be dereferenced before they can be safely sent over a channel.\cb1 \
\cb3 > I don\'92t see any mention of references in the formalism, so this must be one of the differences between the formalism and the implementation? If yes, it should be clearly explained.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 24: Page 14: The code refers to the \'91R\'92, \'91Wk\'92 and \'91V\'92 constructors, which should probably be \'91RecursionPoint\'92, \'91WeakenRecursion\'92 and \'91RecursionVariable\'92 instead.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 25: What about projections from global types to local types? The code later one refers to the type LocalType, which suggests that the projection is implemented. It should at least be mentioned for completeness.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 26: It is not clear what kind of type safety is provided by either of the formalism and the implementation. It would be good if some statement about this were included. See also this comment by Reviewer 1 to the original draft:\cb1 \
\cb3 > > In the discussion, it is mentioned that \'93the type system can actually guarantee that we have not forgotten to revert anything\'94. Is this really true? If so, it is an interesting point which deserves a lot more illustration.\cb1 \
\cb3 >\cb1 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 TO BE DONE! Perhaps in Sect 3.6?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \
>\cb1 \
\cb3 > 27: Page 16:\cb1 \
\cb3 > > Recall the process implementation for thevendor in the three-buyer example\cb1 \
\cb3 >\cb1 \
\cb3 > Please include a page reference.\cb1 \
\cb3 >\
\cf5 Fixed: we included a section reference.\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 28: Page 17:\cb1 \
\cb3 > > follows closely follows\cb1 \
\cb3 >\cb1 \
\cb3 > Pick one.\cb1 \
\cb3 >\
\cf5 Fixed.\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 29: Page 17: Please provide the definition or explanation of Except.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 30: Page 21:\cb1 \
\cb3 > > Note that this scheduler can still get into deadlocks\cb1 \
\cb3 > Is this a property of this particular scheduler, or of the whole formalism? Is there a better scheduler that would avoid such deadlocks?\cb1 \
\cb3 >\cb1 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \
> 31: Page 21:\cb1 \
\cb3 > > B expects the share from V first\cb1 \
\cb3 > V sends the message \'91Price\'92 to B in this example, not \'91Share\'92.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\cf2 \cb3 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 32: Page 21: GlobalTypeF uses the \'91R\'92, \'91Wk\'92 and \'91V\'92 constructors, which don\'92t match the previous definition.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
\pard\pardeftab720\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 > 33: Page 22: Please address this comment of Reviewer 2:\cb1 \
\cb3 > > Page 20: "The definitions correspond directly". Somewhat ironically, you're choosing an example where they don't, because you're using a de-Bruijn encoding to avoid variable names, which means that "V" and "Wk\'94 both correspond to the variable case.\cb1 \
\cb3 >\
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 FOLKERT?\
}