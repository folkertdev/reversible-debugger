\documentclass[runningheads,plain]{llncs}

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath,stmaryrd,enumerate}
\usepackage{ifxetex,ifluatex}
\usepackage{xspace}

\usepackage{xcolor}
\newcommand{\erase}[1]{\textcolor{orange}{#1}}
\newcommand{\modi}[1]{\textcolor{blue}{#1}}
\newcommand{\checkthis}[1]{\textcolor{red}{#1}}
%\newcommand{\checkthis}[1]{#1}
%\newcommand{\secref}[1]{\S\,\ref{#1}}

\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments

% lncs 
\usepackage{makeidx}
%\institute{University of Groningen, The Netherlands, \\ \texttt{}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Folkert de Vries \& Jorge A. Pérez},
            pdftitle={Reversible Session-Based Concurrency in Haskell},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
%\setlength{\parindent}{0pt}
%\setlength{\parskip}{6pt plus 2pt minus 1pt}
%\setlength{\emergencystretch}{3em}  % prevent overfull lines
%\setcounter{secnumdepth}{5}

%\date{}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[toc,page]{appendix}
\newcommand{\hideFromPandoc}[1]{#1}
\hideFromPandoc{ \let\Begin\begin \let\End\end }
\input{macrosCR}

\begin{document}

\title{Reversible Session-Based Concurrency in Haskell}

\author{Folkert de Vries \and
Jorge A. P\'{e}rez%\orcidID{0000-0002-1452-6180}}
}
%
\authorrunning{F.\,de Vries and J.\,A.\,P\'{e}rez}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Groningen, The Netherlands}
\maketitle



\begin{abstract}
A reversible semantics enables to undo computation steps. 
Reversing  
message-passing, concurrent programs is a
challenging and delicate task; one typically aims at
\emph{causally consistent} reversible semantics.
Prior work has addressed this
challenge in the context of a process model of multiparty protocols
(or \emph{choreographies}).
% following a so-called \emph{monitors-as-memories} approach. 
In this paper, we describe a Haskell implementation of 
this reversible operational semantics. 
We exploit algebraic data types to faithfully represent
three core ingredients: a process
calculus, multiparty session types, and forward and backward reduction semantics.
%The latter make it possible to run and typecheckprograms, and 
Our implementation bears witness to the convenience of pure functional programming for implementing reversible languages.
%\pagebreak
\end{abstract}

% lncs keyword extension 
\keywords{Reversibility, message-passing concurrency, session types, Haskell.}



%{
%\hypersetup{linkcolor=black}
%\setcounter{tocdepth}{3}
%\tableofcontents
%}

\section{Introduction}
\label{s:intro}
This paper describes a Haskell implementation of 
a \emph{reversible semantics} for message-passing concurrent programs. 
Our work is framed within a prolific line of research, 
in the intersection of programming languages and concurrency theory,
aimed at establishing  semantic foundations for reversible computing in a 
concurrent setting (see, e.g., the survey~\cite{DBLP:journals/eatcs/Lanese14}).
When considering the interplay of reversibility and message-passing concurrency, 
a key observation  is that
 communication is governed by
\emph{protocols} among  (distributed) partners, and that 
 those protocols may fruitfully inform the implementation of a reversible semantics.

In a language with a reversible semantics, computation steps can be undone.
Thus, a program can perform standard \emph{forward} steps, but also \emph{backward} steps.
Reversing a sequential program is not hard: it suffices to have a \emph{memory} that records information about forward steps in case we wish to return to a prior state using a backward step. Reversing a concurrent program is much more difficult: since control may simultaneously reside in more than one point, memories should be carefully designed so as to record information about the steps performed in each thread, but also about the \emph{causal dependencies} between steps from different threads.
This motivates the definition of reversible semantics which are \emph{causally consistent}, i.e., that ensure that backward steps lead to states that could  have been reached by performing forward steps only~\cite{DBLP:journals/eatcs/Lanese14}. Hence, a causally consistent  semantics never leads to states that are not reachable through forward steps. 

Causal consistency then arises as a key correctness criterion in the definition of reversible programming languages. The quest for causally consistent semantics for (message-passing) concurrency has led to a number of proposals that use  \emph{process calculi} (most notably, the $\pi$-calculus~\cite{MilnerR:calmp1}) to rigorously specify communicating processes and their operational semantics (cf.~\cite{DBLP:conf/ppdp/MezzinaP17} and references therein). One common shortcoming in several of these works is that the proposed causally consistent semantics hinge on memories that are rather heavy; as a result, the resulting (reversible) programming models can be  overly complex. This is a particularly notorious limitation in the work of Mezzina and P\'{e}rez~\cite{DBLP:conf/ppdp/MezzinaP17}, which addresses reversibility in the relevant context of $\pi$-calculus processes that exchange (higher-order) messages following \emph{choreographies}, as defined by \emph{multiparty session types}~\cite{DBLP:conf/popl/HondaYC08} that specify intended protocol executions. While their reversible semantics   is causally consistent, it is unclear whether it can be implemented as the basis of practical tools for the  analysis of message-passing concurrent programs.

In this paper we describe a Haskell implementation of the reversible semantics  by Mezzina and P\'{e}rez~\cite{DBLP:conf/ppdp/MezzinaP17} (the MP model, in the following). As such, our implementation defines a Haskell interpreter of message-passing programs written in their reversible model. This allows us to assess in practice the mechanisms %deployed by Mezzina and P\'{e}rez 
of the MP model
to enforce causally consistent reversibility. The use of a functional programming language (Haskell) is a natural choice for developing our implementation. Haskell has a strong history in language design. Its type system and mathematical nature allow us to faithfully capture the formal reversible semantics and to trust that our implementation  correctly preserves causal consistency. In particular, algebraic data types (sums and products) are essential to express the grammars and recursive data structures underlying the MP model.

%\paragraph{Organization.} %
The rest of the paper is structured as follows.
 \secref{the-process-model} recalls the key notions of the MP model, useful to follow our Haskell implementation, which we detail 
in  \secref{implementing-the-ppdp17-calculus-in-haskell}.
 \secref{running-debugging} explains how to run programs forwards and backwards using our implementation.
 \secref{discussion} collects concluding remarks. 

%For reviewer's convenience, Appendices~\ref{free-monad-dsl} -- \ref{scheduling-code} describe further details about the implementation, including installation instructions.

\section{The MP Model of Reversible Concurrent Processes}
\label{the-process-model}

\begin{figure}[!t]
\begin{center}
    \includegraphics[width=8.7cm]{./img/figmodel.pdf}
\end{center}
\vspace{-8mm}
\caption{The model of multiparty, reversible communications by   Mezzina and P\'erez~\cite{DBLP:conf/ppdp/MezzinaP17}.}\label{f:model}
\vspace{-5mm}
\end{figure}

Our aim is to develop a Haskell implementation of the MP model~\cite{DBLP:conf/ppdp/MezzinaP17}, which is depicted in Fig.~\ref{f:model}. 
Here we shall  informally describe the key elements of the model, guided by a running example. Interested readers are referred to~\cite{DBLP:conf/ppdp/MezzinaP17} for further details, in particular the definition and proof of causal consistency. 

\subsection{Overview}
Fig.~\ref{f:model} depicts two of the three salient ingredients of the MP model:
\emph{configurations/processes} and the
\emph{choreography}, which represent the communicating partners (\emph{participants}) and their intended governing protocol, respectively. 
There is a {configuration} for each participant: it includes a \emph{located process} that relies on asynchronous communication and is subject to a \emph{monitor} that enables forward/backward steps at run-time. This monitor is obtained via the choreography, which describes the intended protocol among the {participants}. 
Choreographies are defined in terms of \emph{global types} as in multiparty session types~\cite{DBLP:conf/popl/HondaYC08}. 
(We often use `choreographies' and `global types' as synonyms.)
A global type is \emph{projected} onto each participant to obtain 
its corresponding  \emph{local type}, which abstracts a participant's contribution to the protocol. 
Since  local types specify the intended communication actions, they may be used as the monitors of the located processes. 

The third ingredient of the MP model, not depicted in Fig.~\ref{f:model}, is the \emph{operational semantics} for configurations, which  is defined by two reduction relations: forward ($\fw$) and backward ($\bk$). We shall not recall these relations here; rather, we will introduce their key underlying intuitions by example---see \secref{ss:exam} below.

\subsection{Configurations and Processes}
\label{ss:processes}
The language  of processes  $P, Q, \ldots$, given next, is a $\pi$-calculus with   labeled  choice, communication of abstractions, and function application:
While labeled choice is typical of session $\pi$-calculi~\cite{DBLP:conf/esop/HondaVK98}, the latter constructs are typical of \emph{higher-order} process calculi, which combine features from functional and concurrent  languages~\cite{DBLP:journals/tcs/Sangiorgi01}. 
%The complete process syntax, with their intuitive semantics, is  as follows:
\begin{align*}
P, Q ::= \, 
        & \bout{u}{V}{P} \,\,\, \, \, &\text{send value $V$ on name $u$, then run $P$} \\
\sbnfbar & \binp{u}{x}{P} \,\,\, \, \, & \text{receive a value on name $u$, bind it to $x$, then run $P$} \\
\sbnfbar &  \bsel{u}{\lbl_i. P_i}_{i\in I}\,\,\, \, \, & \text{select a label $l_j$ ($j \in I$), broadcast this choice, run $P_j$} \\
\sbnfbar & \bbra{u}{\lbl_i:P_i}_{i \in I} \,\,\, \, \, & \text{receive a label  $l_j$ ($j \in I$), run  $P_j$} \\
\sbnfbar   & P \Par Q  &\text{parallel composition of $P$ and $Q$} \\
\sbnfbar  & \rvar{X} \sbnfbar  \recp{X}{P} \,\,\, &\text{variable and process recursion}\\
\sbnfbar & \appl{V}{u} \,\,\, &\text{function application} \\
\sbnfbar  & \news{n}P \,\,\, &\text{name restriction: make $n$ local (or private) to $P$} \\
\sbnfbar  & \inact \,\,\, &\text{terminated process}
\end{align*}
In $\bsel{u}{\lbl_i. P_i}_{i\in I}$ and $\bbra{u}{\lbl_i:P_i}_{i \in I}$, we use $I$ to denote some index set. 
%Notice that $\bsel{u}{\lbl_i. P_i}_{i\in I}$ generalizes the selection construct $\lbl_i. P_i$ in most session languages.
The higher-order character of our process language may be better understood by considering that the syntax of values ($V, W, \ldots$) includes 
\emph{name abstractions} $\lambda x. P$, where $P$ is a process. Formally we have: 
\begin{align*}
u,w  \bnfis& n \sbnfbar x,y,z
\qquad \quad
n,n' \bnfis a,b \sbnfbar \ep{s}{\p}
\qquad \quad
 {v},  {v}'  \bnfis   \true \sbnfbar \false \sbnfbar \cdots
\\
V,W \bnfis & {a,b} \sbnfbar  x,y,z \sbnfbar  v, v' \sbnfbar {\abs{x}{P}}
\end{align*}
\noindent 
where  
$u, w, \ldots$
range over 
names ($n, n', \ldots$) and variables ($x,y,\ldots$).
%We write $v, v', \ldots$ to denote basic values and constants.
We distinguish between shared and session names, 
ranged over
$a,b,c,\ldots$ and $s,s',\ldots$, respectively.
Shared names are public names used to establish a protocol (see below); once established, the protocol runs along a session name, which is private to participants.
We   use $\p, \q, \ldots$ to denote  participants, and 
use session names indexed by participants;  we write, e.g., $s_{[\p]}$.
We also use $v,v',\ldots$ to denote
     base values and constants. 
   %Variables are denoted  $x,y, \ldots$. 
Values $V$ include shared names, 
first-order values, and  {name abstractions}.
Notice that values need not include (indexed) session names: 
session name communication (\emph{delegation}) is  representable using abstraction passing~\cite{KPY2016}.

The syntax of \emph{configurations} $M, N, \ldots$ builds upon that of processes; indeed, we may consider configurations as compositions of located processes:
\begin{align*}
M,N		 \bnfis &
\myloc{\loc}{\bout{a}{x}{P}}
\sbnfbar 
\myloc{\loc}{\binp{a}{x}{P}}
\sbnfbar 
M \Par N 
\sbnfbar 
\news{n} M
\sbnfbar 
\inact 
\\
 \sbnfbar &
{\np{\ep{\loc}{\p}}{\conf{\stack C}{P}}} %% running process
\sbnfbar 
{\monig{\ep{s}{\p}}{H}{\mytilde{x}}{\store}}  %% monitor
 \sbnfbar 
\codah{s}{h_i}{h_o}%{\restrict{\mytilde{\gpart{r}}}}
 % queue
\sbnfbar 
 {\mem{k}{(\appl{V}{u})}{\loc}} % function
\end{align*}
Above,  identifiers $\loc, \loc'$ denote a  \emph{location} or  \emph{site}. 
The first two constructs enable protocol establishment:
$\myloc{\loc}{\bout{a}{x}{P}}$ is the \emph{request} of a service identified by shared name $a$ implemented by
$P$, whereas $\myloc{\loc}{\binp{a}{x}{P}}$ denotes service \emph{acceptance}. 
Establishing an $n$-party protocol on service $a$ then requires one configuration requesting $a$ 
synchronizing with  $n-1$ configurations accepting $a$.
Constructs for  composing configurations, name restriction, and  inaction are as expected.

The second row above shows constructs that appear only at run-time 
%(i.e., they do not appear in ``source'' programs) 
and   enable  reversibility. 

\begin{itemize}
\item  $\np{\ep{\loc}{\p}}{\conf{\stack C}{P}}$ is a \emph{running process}:  location $\loc$ hosts a process $P$ that implements participant $\p$, and $\stack C$ records labeled choices enforced so far. 

\item $\monig{\ep{s}{\p}}{H}{\mytilde{x}}{\store}$ is a \emph{monitor}
where: 
$s_{[\p]}$ is the indexed session being monitored;
$H$ is a  local type \emph{with history} (see below);
$\mytilde{x}$ is a set of free variables;
and store $\store$ records their values.
The \emph{tag} $\mytagg$ says whether 
the running process tied to the monitor is involved in a backward step ($\mytagg = \rmark$) or not ($\mytagg = \normark$).

\item   $\codah{s}{h_i}{h_o}$ is the \emph{message queue} of session $s$, composed of an input part $h_i$ and an output part $h_o$.
Messages sent by output prefixes are placed in the output part; an input prefix takes the first message in the output part and moves it to the input part. Hence, messages in the queue are not consumed but moved between the two parts of the queue.

\item Finally, the \emph{running function} $\mem{k}{(\appl{V}{u})}{\loc}$ serves to reverse the $\beta$-reduction resulting from the application $\appl{V}{u}$. In $\mem{k}{(\appl{V}{u})}{\loc}$, 
 $\loc$ is the location where the application resides, and 
  $k$ is a freshly generated identifier.
\end{itemize}
These intuitions are formalized by the operational semantics of the MP model, which we do not discuss here; see Mezzina and P\'{e}rez's paper~\cite{DBLP:conf/ppdp/MezzinaP17} for details.


\subsection{Global and Local Types}
\label{ss:types}
As already mentioned,  multiparty protocols are expressed as global types ($G, G', \ldots$), which can be \emph{projected} onto local types  ($T, T', \ldots$), one per participant. The syntax 
of value, global, and local types
follows~\cite{DBLP:conf/popl/HondaYC08}:
\begin{align*}
			U, U'  \bnfis & \bool \sbnfbar \nat \sbnfbar \cdots %\bnfbar T 
			\sbnfbar \shot{T} \\
			G, G'  \bnfis & \gtcom{p}{q}{U}{G} %\bnfbar 
			\sbnfbar
			\gtcho{p}{q}{\lbl_i}{G_i} %\\
			\sbnfbar %& 
			\mu X. G \sbnfbar X \sbnfbar \gend \\
	    	T, T'  \bnfis & \ltout{p}{U}{T} \sbnfbar \ltinp{p}{U}{T} %\\
		  \sbnfbar %& 
		  \ltsel{p}{\lbl_i}{T_i}{i}{I} \sbnfbar \ltbra{p}{\lbl_i}{T_i}{i}{I}  
		 %\lsend{p}{\lbl_i}{U_i}{T_i} \bnfbar \lrecv{q}{\lbl_i}{U_i}{T_i} \bnfbar 
		\sbnfbar  \mu X. T \sbnfbar X \sbnfbar \lend 
\end{align*}
\noindent
%tWe briefly discuss 
Value types $U$ include first-order values,   and  
 type $\shot{T}$ for {higher-order} values: abstractions from names to processes
(where $\Proc$ denotes the type of processes).

Global type $\gtcom{p}{q}{U}{G}$ says that \p  sends a value of type $U$ to \q, and then continues as $G$.
Given a finite index set $I$ and pairwise different {labels} $\lbl_i$, global type $\gtcho{p}{q}{\lbl_i}{G_i}$ specifies that  \p may choose  label $\lbl_i$, send this selection to \q, and then continue as $G_i$.
In both cases, $\p \neq \q$.
Recursive and terminated protocols are denoted $\mu X. G$ and $\gend$, respectively.
%We write $\parties{G}$ to denote the set of participants in $G$.

Global types are sequential, but may describe implicit parallelism. 
As a simple example, the global type $G = \gtcom{p}{q}{\bool}{\gtcom{r}{s}{\nat}{\gend}}$
is defined sequentially, but describes two independent  exchanges 
(one involving $\p$ and $\q$, the other involving $\mathtt{r}$ and $\mathtt{s}$)
which could be implemented in parallel.
In this line, $G$ may be regarded to be equivalent to 
$G' = \gtcom{r}{s}{\nat}{\gtcom{p}{q}{\bool}{\gend}}$

Local types are used in the monitors introduced above. 
Local types
%abstract the behavior of individual participants. Types 
$\ltout{p}{U}{T}$ and $\ltinp{p}{U}{T}$ denote, respectively, an output and input of value of type $U$ by \p.
%\added{We use  $\alpha$ to denote type prefixes  $\typeIn{\p}{U}$, $\typeOut{\p}{U}$.}
Type $\ltbra{p}{\lbl_i}{T_i}{i}{I}$ says that \p 
offers different labeled alternatives;
conversely, type $\ltsel{\p}{\lbl_i}{T_i}{i}{I}$ 
says that \p may select one of such alternatives.
Recursive and terminated local types are denoted $\mu X. T$ and $\lend$, respectively. 
 
 A novelty in the MP model are \emph{local types with history}  ($H, H'$). A type $H$ is a local type equipped with a
 cursor (denoted~$\past$) used to distinguish  the  protocol actions  that have been already executed (the past of the protocol) from those that are yet to be performed (the future of the protocol).
 
 \subsection{Projection}\label{projection}
The projection of a global type $G$ onto a participant $\p$, denoted $\tproj{G}{\gpart{p}}$,  is defined in Fig.~\ref{f:proj}. 
 The definition is   self-explanatory, perhaps except for choice.
 Intuitively, projection ensures that a choice between $\p$ and $\q$ should not implicitly determine different behavior for participants different from $\p$ and $\q$, for which any different behavior should  be determined by some explicit communication.
 This is a condition adopted by the MP model but also by several other works, as it ensures decentralized implementability of  multiparty session types.
%To address this, and to ensure implementability of global types,  disallow haviing different branches that use different participants. 
%In practice, 
%this means that all branches must perform the same communication to satisfy the global type, even if the communication is not needed in every branch (some branches may have dummy communications). 
 {Our implementation relies on broadcasts to communicate choices to all protocol participants; this reduces the need for explicit communications in global types}. 
Projection consistently handles 
the combination of recursion and choices in global types. 
In the particular case in which a branch of a choice in the global type may recurse back to the beginning, 
the local types for all involved participants will be themselves recursive; this ensures that 
participants will jump back to the beginning of the protocol in a coordinated way.


\begin{figure}[!t]
{
\begin{align*}
\tproj{(\gtcom{p}{q}{U}{G})}{\gpart{r}} & = 
\begin{cases}
\ltout{q}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{p}$} \\
\ltinp{p}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{q}$} \\
(\tproj{G}{\gpart{r}}) &  \text{if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$}
\end{cases}
\\
\tproj{(\gtcho{p}{q}{l_i}{G_i})}{\gpart{r}}  
& 
{= 
\begin{cases}
\ltsel{q}{\lbl_i}{(\tproj{G_i}{\gpart{r}})}{i}{I}  & \text{ if $\gpart{r} = \gpart{p}$} \\
\ltbra{p}{\lbl_i}{\tproj{G_i}{\gpart{r}}}{i}{I}  & \text{ if $\gpart{r} = \gpart{q}$} \\
(\tproj{{G_1}}{\gpart{r}}) &  \text{ if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$ and} \\ 
& \text{~~$\forall i, j \in I. \tproj{{G_i}}{\gpart{r}} = \tproj{{G_j}}{\gpart{r}}$}
\end{cases}
}
\\
\tproj{(\mu X. G)}{\gpart{r}} &= 
\begin{cases}
\mu X. \tproj{G}{\gpart{r}} & \text{if $\gpart{r}$ occurs in $G$}
\\
\lend & \text{otherwise}
\end{cases}
\\
\tproj{X}{\gpart{r}} & = X
\qquad
\tproj{\gend}{\gpart{r}} = \lend
\end{align*}
}
%\vspace{-6mm}
\caption{Projection of a global type $G$ onto a participant $\gpart{r}$~\cite{DBLP:conf/ppdp/MezzinaP17}.\label{f:proj}}
%\vspace{-5mm}
\end{figure}

\subsection{Example: Three-Buyer Protocol}\label{ss:exam}

We illustrate by example the 
forward and backward reduction semantics, denoted \fw and \bk: we recall the running example by Mezzina and P\'{e}rez~\cite{DBLP:conf/ppdp/MezzinaP17}, namely
  a reversible variant of the \emph{Three-Buyer protocol}  (cf, e.g.,~\cite{CDYP2015})
with abstraction passing (\emph{delegation}). 

\subsubsection{The Protocol as Global and Local Types}
The protocol 
involves three buyers (Alice ($\pA$), Bob ($\pB$), Carol ($\pC$)) who interact with a Vendor ($\pS$) as follows:

\begin{enumerate}[1.]
\item Alice sends a book title to Vendor, which replies back to Alice and Bob with a quote. Alice tells Bob how much she can contribute.
\item Bob notifies Vendor and Alice that he agrees with the price, and asks Carol to assist him in completing the protocol. 
To delegate his remaining interactions with Alice and Vendor to Carol, Bob sends her %both an endpoint and 
the code she must execute.
\item Carol continues the rest of the protocol with Vendor and Alice as if she were Bob. 
She sends Bob's address (contained in the  code she received) to Vendor.
\item Vendor answers to Alice and Carol (representing Bob) with the delivery date.
\end{enumerate}
This protocol may be formalized as the following global type $G$:
\begin{align*}
G = ~&  \gtcom{A}{\pS}{\mathsf{title}}{\gtcom{\pS}{\{A,B\}}{\mathsf{price}}{\gtcom{A}{B}{\mathsf{share}}{
 \gtcom{B}{\{A,\pS\}}{\mathsf{OK}}{\\
& \quad
 \gtcom{B}{C}{\mathsf{share}}{\gtcom{B}{C}{\thunkt}{
\gtcom{B}{\pS}{\mathsf{address}}{ \gtcom{\pS}{B}{\mathsf{date}}{\gend}}}}}}}}
%\\
%G_2 = ~& \gtcom{B}{C}{\mathsf{share}}{\gtcom{B}{C}{T}{\gtcom{B}{C}{\shot{T}}{\gend}}}
\end{align*}
Above,  
$\gtcom{\p}{\{\q_1,\q_2\}}{U}{G}$
stands for 
$\gtcom{\p}{\q_1}{U}{\gtcom{\p}{\q_2}{U}{G}}$
(and similarly for local types).
We write $\thunkt$ to denote the type $\shot{\lend}$, associated to a \emph{thunk} $\abs{x}{P}$ with $x \not \in \fn{P}$, written
$\thunkp{P}$. A thunk is an inactive process, which is activated by applying to it a dummy name of type $\lend$, denoted $\dummyn$.
Also, $\mathsf{price}$ and $\mathsf{share}$ are base types treated as integers;
  $\mathsf{title}$, $\mathsf{OK}$, $\mathsf{address}$, and $\mathsf{date}$ are base types treated as strings.
The projections of $G$ onto local types are as follows:
\begin{align*}
\tproj{G}{\pS} & = \ltinp{A}{\mathsf{title}}{\ltout{\{A,B\}}{\mathsf{price}}{\ltinp{B}{\mathsf{OK}}{\ltinp{B}{\mathsf{address}}{\ltout{B}{\mathsf{date}}{\lend}}}}}
\\
\tproj{G}{\pA} & = \ltout{\pS}{\mathsf{title}}{\ltinp{\pS}{\mathsf{price}}{\ltout{B}{\mathsf{share}}{\ltinp{B}{\mathsf{OK}}{\lend}}}}
\\
\tproj{G}{\pB} & = \ltinp{\pS}{\mathsf{price}}{\ltinp{A}{\mathsf{share}}{\ltout{\{A,\pS\}}{\mathsf{OK}}{
\ltout{C}{\mathsf{share}}{\ltout{C}{\thunkt}{
 \ltout{\pS}{\mathsf{address}}{\ltinp{\pS}{\mathsf{date}}{\lend}}}}}}}
\\
\tproj{G}{\pC} & = \ltinp{B}{\mathsf{share}}{\ltinp{B}{\thunkt}{\lend}}
\end{align*}

\subsubsection{Process Implementations and Their Behavior}
We now give processes for each participant:
\begin{align*}
\text{Vendor} & =  \bout{d}{x:\tproj{G}{\pS}}\binp{x}{t}\bout{x}{price(t)}\bout{x}{price(t)} \binp{x}{ok}\binp{x}{a} \bout{x}{date}\inact  
\\
\text{Alice} & =  \binp{d}{y:\tproj{G}{\pA}}\bout{y}{\exBook}\binp{y}{p}\bout{y}{h}\binp{y}{ok}\inact  
\\
\text{Bob} & =  \binp{d}{z:\tproj{G}{\pB}}\binp{z}{p}\binp{z}{h}\bout{z}{ok}\bout{z}{ok}\bout{z}{h}
 \bbout{z}{\thunkp{\bout{z}{\text{`9747 AG'}}\binp{z}{d}\inact}}\inact
  \\
\text{Carol} & =  \binp{d}{w:\tproj{G}{\pC}}\binp{w}{h}\binp{w}{code}(\appl{code}{\dummyn})
%&Q_B = \bout{y}{share}\bout{y}{T}\bout{y}{R}\inact  \\
%&Q_C = \binp{y}{share}\binp{y}{T}\binp{y}{X}\inact  \\
\end{align*}
where $price(\cdot)$ returns a value of type $\mathsf{price}$ given a $\mathsf{title}$.
 Bob's implementation sends part of its protocol to Carol as a thunk.
 % containing  his session name and address. 
The whole system, given below, is obtained by placing these processes   in appropriate locations ($\loc_1, \ldots, \loc_4$):
$$
M = \myloc{\loc_1}{\text{Vendor}} 
\Par
\myloc{\loc_2}{\text{Alice}} 
\Par
\myloc{\loc_3}{\text{Bob}} 
\Par 
\myloc{\loc_4}{\text{Carol}} 
$$
%\end{document}
We now use $M$ to informally discuss the reduction relations \fw and \bk; below we shall refer to forward and backward reduction rules {defined in Mezzina and P\'{e}rez's paper~\cite[\S\,2.2.2]{DBLP:conf/ppdp/MezzinaP17}}.

From $M$, the session starts with 
an application of  Rule~\fwcolor{\textsc{(Init)}}, which 
defines a forward reduction that
initializes the protocol by creating running processes and monitors:
%To simplify readability, below
%we write 
%$\mathtt{r}$,
%$\mathtt{a}$,
%$\mathtt{b}$,
%and 
%$\mathtt{c}$ 
%instead of participant identities $\mathsf{S}$, $\mathsf{A}$, $\mathsf{B}$, and $\mathsf{C}$, respectively:
%$$
\begin{align*}
%\begin{array}{cc}
M & \fw  \news{s}\big(\, 
\np{\key{{\loc_1}}{\pS}}{ \conf{\inact}{V_1\subst{\epS}{x}}} \Par 
\hmoni{\ep{s}{\pS}}{\past \tproj{G}{\pS}}{x}{\upd{x}{d}}  
\\
& \Par \np{\key{{\loc_2}}{\pA}}{ \conf{\inact}{A_1\subst{\epA}{y}}} \Par 
\hmoni{\ep{s}{\pA}}{\past \tproj{G}{\pA}}{y}{\upd{y}{d}} 
\\
& \Par \np{\key{{\loc_3}}{\pB}}{ \conf{\inact}{B_1\subst{\epB}{z}}} \Par 
\hmoni{\ep{s}{\pB}}{\past \tproj{G}{\pB}}{z}{\upd{z}{d}} 
\\
& \Par \np{\key{{\loc_4}}{\pC}}{ \conf{\inact}{C_1\subst{\epC}{w}}} \Par 
\hmoni{\ep{s}{\pC}}{\past \tproj{G}{\pC}}{w}{\upd{w}{d}}  
  \Par \codah{s}{\emp}{\emp}{}~\big)  = M_1
%\end{array}
\end{align*}
%$$
where 
$V_1\subst{\epS}{x}$, $A_1\subst{\epA}{y}$, $B_1\subst{\epB}{z}$, and $C_1\subst{\epC}{w}$ 
stand for the continuation of processes $\text{Vendor}$, $\text{Alice}$, $\text{Bob}$, and $\text{Carol}$ after the service 
request/accept. 
Observe that $s$ is a fresh session name created after initialization; 
we write  $\subst{\epS}{x}$ to denote a substitution of variable $x$ with session name $\epS$.
%So we have, for instance, 
%$
%A_1 = \bout{y}{\exBook}\binp{y}{p}\bout{y}{h}\binp{y}{ok}\inact
%$.
%Notice also how session initialization instantiates variable ${z}$ in the thunk contained in Bob's implementation with endpoint $\epB$.

From $M_1$ we could either undo this forward reduction (using Rule~\bkcolor{\textsc{(RInit)}})
or execute the communication from $\text{Alice}$ to $\text{Vendor}$,
using Rules~\fwcolor{\textsc{(Out)}} and ~\fwcolor{\textsc{(In)}} as 
%This latter option would be as 
follows:
\begin{align*}
M_1 & \fw  \news{s}(\,  \np{\key{{\loc_2}}{\pA}}{ \conf{\inact}{\binp{\epA}{p}\bout{\epA}{h}\binp{\epA}{ok}\inact}} 
\\
& \!\!\!\!\Par 
\hmoni{\ep{s}{\pA}}{\ltout{\pS}{\mathsf{title}}{\past \ltinp{\pS}{\mathsf{price}}{\ltout{B}{\mathsf{share}}{\ltinp{B}{\mathsf{OK}}{\lend}}}}}{y}{\upd{y}{d}} 
\\
& \!\!\!\!\Par N_2 \Par \codah{s}{\emp}{\valueq{\pA}{\pS}{\exBook}}{}~)  = M_2
\end{align*}
where $N_2$ stands for  processes/monitors for Vendor, Bob, and Carol (not involved in the reduction). 
In $M_2$, the message from $\pA$ to $\pS$ now appears in the output part of the queue.
An additional forward step completes the synchronization:
\begin{align*}
M_2 \fw & \news{s}(\,  \np{\key{{\loc_1}}{\pS}}{ \conf{\inact}{\bout{\epS}{price(t)} \bout{\epS}{price(t)}\binp{\epS}{ok}  \binp{\epS}{a} \bout{\epS}{date}\inact }} 
\\
& \Par 
\hmoni{\ep{s}{\pS}}{\ltinp{A}{\mathsf{title}}{\past \ltout{\{A,B\}}{\mathsf{price}}{T_\pS}}}{x,t}{\store_3}  \Par N_3
\\
&  \Par \codah{s}{\valueq{\pA}{\pS}{\exBook}}{\emp}{}~)  = M_3
\end{align*}
where 
$\store_3  = \upd{x}{d},\upd{t}{\exBook}$,
$T_\mathsf{\pS}  = \ltinp{B}{\mathsf{OK}}{\ltinp{B}{\mathsf{address}}{\ltout{B}{\mathsf{date}}{\lend}}}$,
and $N_3$ stands for the %participants not involved in the reduction.
rest of the system.
Note that the cursors in monitors $\ep{s}{\pS}$ and $\ep{s}{\pA}$ have moved; also, the message from $\pA$ to $\pS$ is now in the input part of the queue.

We now illustrate  reversibility: to return to $M_1$ from $M_3$ we need  three backward 
%steps.
reduction
rules: \bkcolor{\textsc{(RollS)}}, \bkcolor{\textsc{(RIn)}}, and \bkcolor{\textsc{(ROut)}}.
First, Rule~\bkcolor{\textsc{(RollS)}} 
%The first one only 
modifies the tags of monitors $\ep{s}{\pS}$ and $\ep{s}{\pA}$:
\begin{align*}
M_3 & \bk  \news{s}(\,  
\np{\key{{\loc_1}}{\pS}}{ \conf{\inact}{\bout{\epS}{price(t)}\bout{\epS}{price(t)}\binp{\epS}{ok}  \binp{\epS}{a} \bout{\epS}{date}\inact }} 
\\
& \Par 
 \monir{\ep{s}{\pS}}{\ltinp{A}{\mathsf{title}}{\past \ltout{\{A,B\}}{\mathsf{price}}{T_\mathsf{B}}}}{x,t}{\store_3} 
 \Par \np{\key{{\loc_2}}{\pA}}{ \conf{\inact}{\binp{\epA}{p}\bout{\epA}{h}\binp{\epA}{ok}\inact}} 
\\
& \Par 
\monir{\ep{s}{\pA}}{\myctxr{\ctx{T}_4}{\past \ltinp{\pS}{\mathsf{price}}{\ltout{B}{\mathsf{share}}{\ltinp{B}{\mathsf{OK}}{\lend}}}}}{y}{\upd{y}{d}} 
\\
& \Par N_4 \Par \codah{s}{\valueq{\pA}{\pS}{\exBook}}{\emp}{}~)  = M_4
\end{align*}
where 
$\myctxr{\ctx{T}_4}{\bullet}  =\ltout{\pS}{\mathsf{title}}{\bullet}$ is a  \emph{type context} (with hole $\bullet$) and, as before, $N_4$ represents the rest of the system.

$M_4$ has several possible forward and backward reductions. 
One particular backward reduction 
uses Rule~\bkcolor{\textsc{(RIn)}} to 
undo the input at \pS:
\begin{align*}
M_4 & \bk  \news{s}(\,  
\np{\key{{\loc_1}}{\pS}}{ \conf{\inact}{\binp{\epS}{t}\bout{\epS}{price(t)}\bout{\epS}{price(t)}   \binp{\epS}{ok}\binp{\epS}{a} \bout{\epS}{date}\inact }} 
\\
& \Par 
 \hmoni{\ep{s}{\pS}}{\past \ltinp{A}{\mathsf{title}}{\ltout{\{A,B\}}{\mathsf{price}}{T_\mathsf{B}}}}{x}{\upd{x}{d}} 
\\
& \Par \np{\key{{\loc_2}}{\pA}}{ \conf{\inact}{\binp{\epA}{p}\bout{\epA}{h}\binp{\epA}{ok}\inact}} 
\\
& \Par 
\monir{\ep{s}{\pA}}{\myctxr{\ctx{T}_4}{\past \ltinp{\pS}{\mathsf{price}}{\ltout{B}{\mathsf{share}}{\ltinp{B}{\mathsf{OK}}{\lend}}}}}{y}{\upd{y}{d}} 
\\
& \Par N_4 \Par \codah{s}{\emp}{\valueq{\pA}{\pS}{\exBook}}{}~)  = M_5
\end{align*}
As a result, the message from $\pA$ to $\pS$ is back again in the output part of the queue.
The following backward reduction from $M_5$ 
uses Rule~\bkcolor{\textsc{(ROut)}}
to undo the output at \pA:
\begin{align*}
M_5 & \bk  \news{s}(\,  
\np{\key{{\loc_1}}{\pS}}{ \conf{\inact}{\binp{\epS}{t}\bout{\epS}{price(t)}\bout{\epS}{price(t)} \\ 
&   \binp{\epS}{ok}\binp{\epS}{a} \bout{\epS}{date}\inact }} 
 \Par 
 \hmoni{\ep{s}{\pS}}{\!\!\past \ltinp{A}{\mathsf{title}}{\ltout{\{A,B\}}{\mathsf{price}}{T_\mathsf{B}}}}{x}{\upd{x}{d}} 
\\
& \!\!\!\! \Par \np{\key{{\loc_2}}{\pA}}{ \conf{\inact}{\bout{\epA}{\exBook}\binp{\epA}{p}\bout{\epA}{h}\binp{\epA}{ok}\inact}} 
\\
& \!\!\!\!\Par 
\hmoni{\ep{s}{\pA}}{\!\!\past \ltout{\pS}{\mathsf{title}}{\ltinp{\pS}{\mathsf{price}}{\ltout{B}{\mathsf{share}}{\ltinp{B}{\mathsf{OK}}{\lend}}}}}{y}{\upd{y}{d}} 
\\
& \!\!\!\! 
\Par N_4 \Par \codah{s}{\emp}{\emp}{}~)  = M_6
\end{align*}
Clearly, $M_6 = M_1$.
Summing up, the forward reductions
$M_1 \fw M_2 \fw M_3$ can be reversed by the backward reductions
$M_3 \bk M_4 \bk M_5 \bk M_6 = M_1$.

\subsubsection{Abstraction Passing (Delegation)}
To illustrate abstraction passing, let us assume that 
$M_3$ above performs forward reductions
until the configuration:
\begin{align*}
M_7 = ~ &   \news{s}(\,  \np{\key{{\loc_3}}{\pB}}{ \conf{\inact}{\bbout{\epB}{\thunkp{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}}\inact}} 
\\
& \!\!\!\! \Par \hmoni{\ep{s}{\pB}}{\myctxr{\ctx{T}_7}{\past \ltout{C}{\thunkt}{\ltout{\pS}{\mathsf{address}}{\ltinp{\pS}{\mathsf{date}}{\lend}}}}}{z,p,h}{\store_7} 
\\
& \!\!\!\! \Par \np{\key{{\loc_4}}{\pC}}{ \conf{\inact}{\binp{\epC}{code}(\appl{code}{\dummyn})}} 
\\
&  \!\!\!\! \Par 
\hmoni{\ep{s}{\pC}}{\myctxr{\ctx{T}_8}{\past \ltinp{B}{\thunkt}{\lend}}}{w,h}{\store_8} 
\Par N_5 \Par \codah{s}{h_7}{\emp}{}~) 
\end{align*}
where 
$\thunkp{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}$
is a thunk (to be activated with the dummy value $\dummyn$) and 
$\myctxr{\ctx{T}_7}{\bullet}$, $\store_7$, $\myctxr{\ctx{T}_8}{\bullet}$, $\store_8$,
and $h_7$ capture past interactions as follows:
\begin{align*}
\myctxr{\ctx{T}_7}{\bullet} & =
\ltinp{\pS}{\mathsf{price}}{\ltinp{A}{\mathsf{share}}{\ltout{\{A,\pS\}}{\mathsf{OK}}{
\ltout{C}{\mathsf{share}}{\bullet}}}}
\\
\store_7 & = \upd{z}{d},\upd{p}{price(\exBook)},\upd{h}{120}
\\
\myctxr{\ctx{T}_8}{\bullet} & =\ltinp{B}{\mathsf{share}}{\bullet} \qquad \store_8  = \upd{w}{d},\upd{h}{120}
\\
h_7 & = 
\valueq{\pA}{\pS}{\exBook}
\\
& \cons
\valueq{\pS}{\pA}{price(\exBook)}
\cons
\valueq{\pS}{\pB}{price(\exBook)}
\\
& \cons
\valueq{\pA}{\pB}{120}
\cons
\valueq{\pB}{\pA}{\text{`ok'}}
\cons
\valueq{\pB}{\pS}{\text{`ok'}}
\cons
\valueq{\pB}{\pC}{120}
\end{align*}
%Also, $120 - price(\exBook)$ is the amount \pB may contribute.

If $M_7 \fw \fw M_8$ to enable a (forward) synchronization 
%by using Rules~\fwcolor{\textsc{(Out)}} and ~\fwcolor{\textsc{(In)}}
we would have:
\begin{align*}
M_8 & = ~   \news{s}(\,  \np{\key{{\loc_3}}{\pB}}{ \conf{\inact}{\inact}} 
\Par \hmoni{\ep{s}{\pB}}{\myctxr{\ctx{T}_7}{\ltout{C}{\thunkt}{\past\ltout{\pS}{\mathsf{address}}{\ltinp{\pS}{\mathsf{date}}{\lend}}}}}{z,p,h}{\store_7} 
\\
%& \Par \hmoni{\ep{s}{\pB}}{\myctxr{\ctx{T}_7}{\ltout{C}{\thunkt}{\past\ltout{\pS}{\mathsf{address}}{\ltinp{\pS}{\mathsf{date}}{\lend}}}}}{z,p,h}{\store_7} 
%\\
& \Par \np{\key{{\loc_4}}{\pC}}{ \conf{\inact}{(\appl{code}{\dummyn}) }} 
 \Par 
\hmoni{\ep{s}{\pC}}{\myctxr{\ctx{T}_8}{ \ltinp{B}{\thunkt}{\past\lend}}}{w,h,code}{\store_9} 
\\
& 
\Par N_5 \Par \codah{s}{h_7 \cons \valueq{\pB}{\pC}{\thunkp{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}}}{\emp}{}~) 
\end{align*}
where
$\store_9 = \store_8 \upd{code}{\thunkp{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}}$.
We now may 
%apply Rule~\fwcolor{\textsc{(Beta)}} to 
obtain the actual code sent from \pB to \pC:
\begin{align*}
M_8 & \fw ~   \news{s}\news{k}(\,  
%\np{\key{\loc_3}{\pB}}{ \conf{\inact}{\inact}} 
%\\
%& \Par \hmoni{s_\pB}{\myctxr{\ctx{T}_7}{\ltout{C}{\thunkt}{\past\ltout{S}{\mathsf{address}}{\ltinp{S}{\mathsf{date}}{\lend}}}}}{z,p,s}{\store_7} 
%\\
%& \Par 
\np{\key{{\loc_4}}{\pC}}{\conf{\inact}{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}} 
\!\!  \Par N_6 
\\
& \!\!\Par \hmoni{\ep{s}{\pB}}{\myctxr{\ctx{T}_7}{\ltout{C}{\thunkt}{\past\ltout{\pS}{\mathsf{address}}{\ltinp{\pS}{\mathsf{date}}{\lend}}}}}{z,p,h}{\store_7} 
\\
& \!\!\Par 
\mem{k}{(\appl{code}{\dummyn})}{{\loc_4}} 
\Par 
\hmoni{\ep{s}{\pC}}{\myctxr{\ctx{T}_8}{ \ltinp{B}{\thunkt}{k.\past\lend}}}{w,h,code}{\store_9} 
\\
& 
\!\!\Par \codah{s}{h_7 \cons \valueq{\pB}{\pC}{\thunkp{\bout{\epB}{\text{`9747 AG'}}\binp{\epB}{d}\inact}}}{\emp}{}~) 
= M_9
\end{align*}
where $N_6$ is the rest of the system. 
Notice that this reduction has added a running function on a fresh 
$k$, which is also used  in the type stored in the monitor $\ep{s}{\pC}$.

The reduction $M_8 \fw M_9$ completes the code mobility from $\pB$ to $\pC$: the now active thunk
will execute $\pB$'s protocol from $\pC$'s location. Observe that Bob's identity \pB is ``hardwired'' in the sent thunk; 
there is no way for \pC to execute the code by referring to a participant different  from \pB.
%This justifies the premise 
%$\p = \er \,\vee\, \p \in \names{\er, h_i}$ present in Rules~\fwcolor{\textsc{(Out)}} and \fwcolor{\textsc{(In)}} 
%\erase{\fwcolor{\textsc{(Sel)}} and ~\fwcolor{\textsc{(Bra)}}} (and in their backward counterparts):
%When executing previously received mobile code, the participant mentioned in the location (i.e., $\pC$)
%and that mentioned in the located process (i.e., $\pB$) may differ.
%Further  reductions from $M_9$ will  modify the cursor in the type stored in   $\ep{s}{\pB}$
%based on the process   at $\key{{\loc_4}}{\pC}$.



\section{Implementing the MP model in Haskell}
%\textbf{\emph{In this section we show how we implement the processes, types, and semantics in the PPDP paper}}
\label{implementing-the-ppdp17-calculus-in-haskell}

We represent the process calculus, global types, local types, and the information for reversal as syntax trees. 
Local types are obtained by from the global type via projection, following \secref{projection}, 
whereas processes and global types 
  written by the programmer. For this reason, we want to provide a convenient way to specify them as domain-specific languages~(DSLs). 

\subsection{DSLs with the Free monad}

Free monads are a common way of defining DSLs in Haskell, mainly because they allow the use of do-notation to write programs in the DSL.
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Free}\NormalTok{ f a   }
    \FunctionTok{=} \DataTypeTok{Pure}\NormalTok{ a    }
    \FunctionTok{|} \DataTypeTok{Free}\NormalTok{ (f (}\DataTypeTok{Free}\NormalTok{ f a))   }
\end{Highlighting}
\end{Shaded}

A simple practical example is a stack-based calculator:
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Operation}\NormalTok{ next  }
    \FunctionTok{=} \DataTypeTok{Push} \DataTypeTok{Int}\NormalTok{ next}
    \FunctionTok{|} \DataTypeTok{Pop}\NormalTok{ (}\DataTypeTok{Maybe} \DataTypeTok{Int} \OtherTok{->}\NormalTok{ next) }
    \FunctionTok{|} \DataTypeTok{End}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{)  }
\KeywordTok{type} \DataTypeTok{Program}\NormalTok{ next }\FunctionTok{=} \DataTypeTok{Free} \DataTypeTok{Operation}\NormalTok{ next}
\KeywordTok{type} \DataTypeTok{TerminatingProgram} \FunctionTok{=} \DataTypeTok{Program} \DataTypeTok{Void}
\end{Highlighting}
\end{Shaded}

We define a data type with our instructions, and make sure it has a \texttt{Functor} instance (i.e., there exists a function \texttt{fmap :: (a -> b) -> Operation a -> Operation b}).
This instance is automatically derived using the \texttt{DeriveFunctor} language extension.
Given an instance of \texttt{Functor}, \texttt{Free} returns the free monad on that functor. 
 {In this example, the free monad on \texttt{Operation} describes a list of instructions.} 

In general, a value of type `\texttt{Free Operation a}' describes a program with holes: an incomplete program with placeholder values of type \texttt{a} in the position of some continuations. 
Composition allows filling in the holes with (possibly incomplete) subprograms. 
The holes are places where the \texttt{Pure} constructor occurs in the program. When evaluating, we want to have a tree without holes. We can levarage the type system to guarantee that \texttt{Pure}
does not occur in the programs we evaluate by using \texttt{Void}.

\texttt{Void} is the data type with zero values (similar to the empty set). 
Thus, a value of the type
\texttt{Free\ Operation\ Void} cannot be of the shape \texttt{Pure\ \_}, because it requires a value of type \texttt{Void}.
An alternative approach is to use existential quantification, which requires enabling a language extension.

We define wrappers around the constructors for convenience. The \texttt{liftF} function takes a concrete value of our program functor (\texttt{ProgramF a}) and turns it into a 
free value (\texttt{Free ProgramF a}, i.e., \texttt{Program a}).
The helpers are used to write programs with do-notation:
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- specialized version of liftF for Free}
\OtherTok{liftF ::} \NormalTok{(}\DataTypeTok{Functor}\NormalTok{ f) => f a -> }\DataTypeTok{Free}\NormalTok{ f a}
\OtherTok{push ::} \DataTypeTok{Int} \OtherTok{->} \DataTypeTok{Program}\NormalTok{ ()}
\NormalTok{push v }\FunctionTok{=}\NormalTok{ liftF (}\DataTypeTok{Push}\NormalTok{ v ())   }
\OtherTok{pop ::} \DataTypeTok{Program}\NormalTok{ (}\DataTypeTok{Maybe} \DataTypeTok{Int}\NormalTok{) }
\NormalTok{pop }\FunctionTok{=}\NormalTok{ liftF (}\DataTypeTok{Pop}\NormalTok{ id)}
\OtherTok{terminate ::} \DataTypeTok{TerminatingProgram}  
\NormalTok{terminate }\FunctionTok{=}\NormalTok{ liftF }\DataTypeTok{End}
\OtherTok{program ::} \DataTypeTok{TerminatingProgram}  
\NormalTok{program }\FunctionTok{=} \KeywordTok{do}    
\NormalTok{    push }\DecValTok{5}  
\NormalTok{    push }\DecValTok{4}  
    \DataTypeTok{Just}\NormalTok{ a }\OtherTok{<-}\NormalTok{ pop    }
    \DataTypeTok{Just}\NormalTok{ b }\OtherTok{<-}\NormalTok{ pop    }
\NormalTok{    push (a }\FunctionTok{+}\NormalTok{ b)    }
\NormalTok{    terminate}
\end{Highlighting}
\end{Shaded}

Finally, we expose a function to evaluate the structure (but
only if it is finite). Typically, a \texttt{Free} monad is transformed
into some other monad, which in turn is evaluated. Here we can first transform into \texttt{State}, and then evaluate that.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpret ::} \DataTypeTok{TerminatingProgram} \OtherTok{->} \DataTypeTok{State}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] () }
\NormalTok{interpret instruction }\FunctionTok{=} 
    \KeywordTok{case}\NormalTok{ instruction }\KeywordTok{of}
        \DataTypeTok{Pure}\NormalTok{ _ }\OtherTok{->} 
            \CommentTok{-- cannot occur}
\NormalTok{            return () }
        \DataTypeTok{Free} \DataTypeTok{End} \OtherTok{->} 
\NormalTok{            return () }
        \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Push}\NormalTok{ a next) }\OtherTok{->} \KeywordTok{do} 
\NormalTok{            State.modify (\textbackslash{}state }\OtherTok{->}\NormalTok{ a }\FunctionTok{:}\NormalTok{ state)}
\NormalTok{            interpret next}
        \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Pop}\NormalTok{ toNext) }\OtherTok{->} \KeywordTok{do}
\NormalTok{            state }\OtherTok{<-}\NormalTok{ State.get}
            \KeywordTok{case}\NormalTok{ state }\KeywordTok{of} 
\NormalTok{                x}\FunctionTok{:}\NormalTok{xs }\OtherTok{->} \KeywordTok{do}
\NormalTok{                    State.put xs}
\NormalTok{                    interpret (toNext (}\DataTypeTok{Just}\NormalTok{ x))}
\NormalTok{                [] }\OtherTok{->} 
\NormalTok{                    interpret (toNext }\DataTypeTok{Nothing}\NormalTok{)}

\OtherTok{evaluate ::} \DataTypeTok{TerminatingProgram} \OtherTok{->}\NormalTok{ [}\DataTypeTok{Int}\NormalTok{] }
\NormalTok{evaluate }\FunctionTok{=}\NormalTok{ flip execState [] }\FunctionTok{.}\NormalTok{ interpret }
\end{Highlighting}
\end{Shaded}


\subsection{Implementing Processes}
The implementation uses an algebraic data type %(also known as union type or sum type) 
to encode all the process constructors in the process syntax of $P$ given in \secref{ss:processes}. 
Apart from the process-level recursion, \texttt{Program} is a direct translation of that process syntax:.

% \KeywordTok{type} \DataTypeTok{Program}\NormalTok{ value }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{ProgramF}\NormalTok{ value) }
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Participant} \FunctionTok{=} \DataTypeTok{String}
\KeywordTok{type} \DataTypeTok{Identifier} \FunctionTok{=} \DataTypeTok{String}

\KeywordTok{data} \DataTypeTok{ProgramF}\NormalTok{ value next }
    \CommentTok{-- communication primitives}
    \FunctionTok{=} \DataTypeTok{Send} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ value ::}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \DataTypeTok{Receive} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ variableName ::} \DataTypeTok{Identifier}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next  }
\NormalTok{        \}}
 \CommentTok{-- choice primitives}
    \FunctionTok{|} \DataTypeTok{Offer} \DataTypeTok{Participant}\NormalTok{ [}\NormalTok{(}\DataTypeTok{String}\NormalTok{, next)]}
    \FunctionTok{|} \DataTypeTok{Select} \DataTypeTok{Participant}\NormalTok{ [}\NormalTok{(}\DataTypeTok{String}\NormalTok{, value, next)]}
 \CommentTok{-- other constructors }
    \FunctionTok{|} \DataTypeTok{Parallel}\NormalTok{ next next }
    \FunctionTok{|} \DataTypeTok{Application} \DataTypeTok{Identifier}\NormalTok{ value}
    \FunctionTok{|} \DataTypeTok{NoOp}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\noindent
As already discussed, processes exchange values. 
With respect to the syntax of values $V, W$ discussed in \secref{ss:processes},
the \texttt{Value} type, given below, has some extra constructors which allow us to write more interesting examples: 
we have added integers, strings, and basic integer and comparison operators. 
We use \texttt{VReference} to denote the variables present in the formal syntax for $V$.
The \texttt{Value} type also includes the label used to differentiate the different cases of offer and select statements.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Value} 
    \FunctionTok{=} \DataTypeTok{VBool} \DataTypeTok{Bool}
    \FunctionTok{|} \DataTypeTok{VInt} \DataTypeTok{Int}
    \FunctionTok{|} \DataTypeTok{VString} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{VUnit}
    \FunctionTok{|} \DataTypeTok{VIntOperator} \DataTypeTok{Value} \DataTypeTok{IntOperator} \DataTypeTok{Value} 
    \FunctionTok{|} \DataTypeTok{VComparison} \DataTypeTok{Value} \DataTypeTok{Ordering} \DataTypeTok{Value}
    \FunctionTok{|} \DataTypeTok{VFunction} \DataTypeTok{Identifier}\NormalTok{ (}\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{)}
    \FunctionTok{|} \DataTypeTok{VReference} \DataTypeTok{Identifier} 
    \FunctionTok{|} \DataTypeTok{VLabel} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

We need some extra concepts to actually write programs with this syntax.

\subsubsection{Delegation via Abstraction Passing.}\label{abstraction-passing}
Delegation occurs when a participant can send (part of)
its protocol to be fulfilled (i.e., implemented) by another participant. 
This mechanism was illustrated 
in the example in \secref{ss:exam}, where Carol acts on behalf of Bob by receiving and executing his code.
For further illustration of the convenience of this mechanism, 
consider a  load balancing server: from the client's
perspective, the server handles the request, but actually the load
balancer delegates incoming requests to workers. The client does not
need to be aware of this implementation detail.
Recall the definition of \texttt{ProgramF}, given just above:
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ProgramF}\NormalTok{ value next }
    \CommentTok{-- communication primitives}
    \FunctionTok{=} \DataTypeTok{Send} 
\NormalTok{        \{}\OtherTok{ owner ::} \DataTypeTok{Participant}
\NormalTok{        ,}\OtherTok{ value ::}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \FunctionTok{...} 
\end{Highlighting}
\end{Shaded}
The \texttt{ProgramF} constructors that move the local type forward
(send/receive, select/offer) have an \texttt{owner} field that stores
whose local type they should be checked against and modify. 
In the formal definition of the MP model, the connection between local types and processes/participants is enforced by the operational semantics.
The \texttt{owner} field is
also present in \texttt{TypeContext}, the data type we define for representing local types in \secref{a-reversible-semantics}. 

\checkthis{Because variables are not shared between sessions, all variables (in the arguments to operators and in function bodies) 
must be dereferenced before a value can be safely sent over a channel}.

\subsubsection{A Convenient DSL.}\label{high-level-dsl}
{
Many of the \texttt{ProgramF} constructors require an \texttt{owner}; we
can thread the owner through a block with a wrapper around
\texttt{Free}. We use \texttt{StateT} containing the owner and a counter
to generate unique variable names.}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{HighLevelProgram}\NormalTok{ a }\FunctionTok{=} 
    \DataTypeTok{HighLevelProgram}\NormalTok{ (}\DataTypeTok{StateT}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{)) a)}
        \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{, }\DataTypeTok{Applicative}\NormalTok{, }\DataTypeTok{Monad}
\NormalTok{        , }\DataTypeTok{MonadState}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{), }\DataTypeTok{MonadFree}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{))}

\OtherTok{uniqueVariableName ::} \DataTypeTok{HighLevelProgram} \DataTypeTok{String}
\NormalTok{uniqueVariableName }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    (participant, n) }\OtherTok{<-}\NormalTok{ State.get}
\NormalTok{    State.put (participant, n }\FunctionTok{+} \DecValTok{1}\NormalTok{)}
\NormalTok{    return }\FunctionTok{$} \StringTok{"var"} \FunctionTok{++}\NormalTok{ show n}

\OtherTok{send ::} \DataTypeTok{Value} \OtherTok{->} \DataTypeTok{HighLevelProgram}\NormalTok{ ()}
\NormalTok{send value }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    (participant, _) }\OtherTok{<-}\NormalTok{ State.get}
\NormalTok{    liftF (}\DataTypeTok{Send}\NormalTok{ participant value ())  }

\OtherTok{receive ::} \DataTypeTok{HighLevelProgram} \DataTypeTok{Value}
\NormalTok{receive }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    (participant, _) }\OtherTok{<-}\NormalTok{ State.get}
\NormalTok{    variableName }\OtherTok{<-}\NormalTok{ uniqueVariableName }
\NormalTok{    liftF (}\DataTypeTok{Receive}\NormalTok{ participant variableName ())}
\NormalTok{    return (}\DataTypeTok{VReference}\NormalTok{ variableName)}

\OtherTok{terminate ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{terminate }\FunctionTok{=}\NormalTok{ liftF }\DataTypeTok{NoOp}

\OtherTok{compile ::} \DataTypeTok{Participant} \OtherTok{->} \DataTypeTok{HighLevelProgram} \DataTypeTok{Void} \OtherTok{->} \DataTypeTok{Program} \DataTypeTok{Value}
\NormalTok{compile participant (}\DataTypeTok{HighLevelProgram}\NormalTok{ program) }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    runStateT program (participant, }\DecValTok{0}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

We can now implement the \texttt{Vendor} from the three-buyer example as:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{vendor ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{vendor }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    t }\OtherTok{<-}\NormalTok{ H.receive}
\NormalTok{    H.send (price t)}
\NormalTok{    H.send (price t)}
    \FunctionTok{...}
\NormalTok{    terminate}
\end{Highlighting}
\end{Shaded}

\subsection{Global Types}
Following Fig.~\ref{f:model}, our implementation uses a global type specification to obtain a local type, one per participant, by means of projection. This is  implemented as described in  \secref{projection}.
Much like the process syntax, the specification of the global types discussed in \secref{ss:types} closely mimics the formal definition:
%Its implementation is given by: 

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{GlobalType}\NormalTok{ participant u a }\FunctionTok{=} 
    \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{GlobalTypeF}\NormalTok{ participant u) a }

\KeywordTok{type} \DataTypeTok{TerminatingGlobalType}\NormalTok{ participant u }\FunctionTok{=} 
    \DataTypeTok{GlobalType}\NormalTok{ participant u }\DataTypeTok{Void}

\KeywordTok{data} \DataTypeTok{GlobalTypeF}\NormalTok{ participant u next}
    \FunctionTok{=} \DataTypeTok{Transaction} 
\NormalTok{        \{}\OtherTok{ from ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ to ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ tipe ::}\NormalTok{ u}
\NormalTok{        ,}\OtherTok{ continuation ::}\NormalTok{  next }
\NormalTok{        \} }
    \FunctionTok{|} \DataTypeTok{Choice} 
\NormalTok{        \{}\OtherTok{ from ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ to ::}\NormalTok{ participant}
\NormalTok{        ,}\OtherTok{ options ::} \DataTypeTok{Map} \DataTypeTok{String}\NormalTok{ next }
\NormalTok{        \}}
    \FunctionTok{|} \DataTypeTok{End}
    \FunctionTok{|} \DataTypeTok{RecursionPoint}\NormalTok{ next}
    \FunctionTok{|} \DataTypeTok{RecursionVariable}
    \FunctionTok{|} \DataTypeTok{WeakenRecursion}\NormalTok{ next}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

%We can now see why choice is useful: it allows us to branch on the session type level. For instance, one branch can terminate the protocol, and the other can loop back to start the protocol again from the beginning.

\noindent where we use `\texttt{tipe}' because `\texttt{type}' is a reserved keyword in Haskell. 

Constructors \texttt{RecursionPoint}, \texttt{RecursionVariable}, and  \texttt{WeakenRecursion} are required to support nested
recursion; they are taken from van Walree's work~\cite{van2017session}. A
\texttt{RecursionPoint} is a point in the protocol to which we can 
jump back later. A \texttt{RecursionVariable} triggers jumping to a
previously encountered \texttt{RecursionPoint}. By default, it will jump
to the closest and most recently encountered \texttt{RecursionPoint},
but \texttt{WeakenRecursion} makes it jump one \texttt{RecursionPoint}
higher; encountering two weakens will jump two levels higher, etc.

We use \texttt{Monad.Free} to build a DSL for defining global types:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{message ::}\NormalTok{ participant }\OtherTok{->}\NormalTok{ participant }\OtherTok{->}\NormalTok{ tipe }\OtherTok{->} \DataTypeTok{GlobalType}\NormalTok{ participant tipe () }
\NormalTok{message from to tipe }\FunctionTok{=}\NormalTok{ liftF (}\DataTypeTok{Transaction}\NormalTok{ from to tipe ())}

\OtherTok{messages ::}\NormalTok{ participant }\OtherTok{->} \NormalTok{[participant]}
         \OtherTok{->}\NormalTok{ tipe }\OtherTok{->} \DataTypeTok{GlobalType}\NormalTok{ participant tipe () }
\NormalTok{messages sender receivers tipe }\FunctionTok{=}\NormalTok{ go receivers }
  \KeywordTok{where}\NormalTok{ go [] }\FunctionTok{=} \DataTypeTok{Pure}\NormalTok{ ()}
\NormalTok{        go (x}\FunctionTok{:}\NormalTok{xs) }\FunctionTok{=} \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Transaction}\NormalTok{ sender x tipe }\FunctionTok{$}\NormalTok{ go xs)}

\OtherTok{oneOf ::}\NormalTok{ participant }\OtherTok{->}\NormalTok{ participant }
      \OtherTok{->} \NormalTok{[(}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{GlobalType}\NormalTok{ participant u a)] }
      \OtherTok{->} \DataTypeTok{GlobalType}\NormalTok{ participant u a }
\NormalTok{oneOf selector offerer options }\FunctionTok{=} 
    \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Choice}\NormalTok{ selector offerer (Map.fromList options))}

\OtherTok{recurse ::} \DataTypeTok{GlobalType}\NormalTok{ p u a }\OtherTok{->} \DataTypeTok{GlobalType}\NormalTok{ p u a}
\NormalTok{recurse cont }\FunctionTok{=} \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{RecursionPoint}\NormalTok{ cont)}

\OtherTok{weakenRecursion ::} \DataTypeTok{GlobalType}\NormalTok{ p u a }\OtherTok{->} \DataTypeTok{GlobalType}\NormalTok{ p u a}
\NormalTok{weakenRecursion cont }\FunctionTok{=} \DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{WeakenRecursion}\NormalTok{ cont)}

\OtherTok{recursionVariable ::} \DataTypeTok{GlobalType}\NormalTok{ p u a }
\NormalTok{recursionVariable }\FunctionTok{=} \DataTypeTok{Free} \DataTypeTok{RecursionVariable}

\OtherTok{end ::} \DataTypeTok{TerminatingGlobalType}\NormalTok{ p u  }
\NormalTok{end }\FunctionTok{=} \DataTypeTok{Free} \DataTypeTok{End}
\end{Highlighting}
\end{Shaded}

\begin{example}[Nested Recursion]
The snippet below illustrates nested recursion. There is an outer
loop that will perform a piece of protocol or end, and an inner loop
that sends messages from \texttt{A} to \texttt{B}. When the inner loop
is done, control flow returns to the outer loop:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import }\DataTypeTok{GlobalType} \KeywordTok{as} \DataTypeTok{G}

\NormalTok{G.recurse }\FunctionTok{$} \CommentTok{-- recursion point 1}
\NormalTok{    G.oneOf }\DataTypeTok{A} \DataTypeTok{B}
\NormalTok{        [ (}\StringTok{"loop"}
\NormalTok{          , G.recurse }\FunctionTok{$} \CommentTok{-- recursion point 2}
\NormalTok{                G.oneOf }\DataTypeTok{A} \DataTypeTok{B}
\NormalTok{                    [ (}\StringTok{"continueLoop"}\NormalTok{, }\KeywordTok{do} 
\NormalTok{                        G.message }\DataTypeTok{A} \DataTypeTok{B} \StringTok{"date"}
                        \CommentTok{-- jumps to recursion point 2}
\NormalTok{                        G.recursionVariable}
\NormalTok{                      )}
\NormalTok{                    , (}\StringTok{"endInnerLoop"}\NormalTok{, }\KeywordTok{do} 
                        \CommentTok{-- jumps to recursion point 1}
\NormalTok{                        G.weakenRecursion G.recursionVariable}
\NormalTok{                      )}
\NormalTok{                    ]}
\NormalTok{          )}
\NormalTok{        , (}\StringTok{"end"}\NormalTok{, G.end)}
\NormalTok{        ]}
\end{Highlighting}
\end{Shaded}
\end{example}

\noindent
Similarly, the global type for three-buyer example (cf. \secref{ss:exam}) can be written as:
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- a data type representing the participants}
\KeywordTok{data} \DataTypeTok{MyParticipants} \FunctionTok{=} \DataTypeTok{A} \FunctionTok{|} \DataTypeTok{B} \FunctionTok{|} \DataTypeTok{C} \FunctionTok{|} \DataTypeTok{V} 
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Ord}\NormalTok{, }\DataTypeTok{Enum}\NormalTok{, }\DataTypeTok{Bounded}\NormalTok{)}
\CommentTok{-- a data type representing the used types }
\KeywordTok{data} \DataTypeTok{MyType} \FunctionTok{=} \DataTypeTok{Title} \FunctionTok{|} \DataTypeTok{Price} \FunctionTok{|} \DataTypeTok{Share} \FunctionTok{|} \DataTypeTok{Ok} \FunctionTok{|} \DataTypeTok{Thunk} \FunctionTok{|} \DataTypeTok{Address} \FunctionTok{|} \DataTypeTok{Date}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Ord}\NormalTok{)}
\CommentTok{-- a description of the protocol}
\OtherTok{globalType ::} \DataTypeTok{TerminatingGlobalType} \DataTypeTok{MyParticipants} \DataTypeTok{MyType}
\NormalTok{globalType }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title} 
\NormalTok{    messages }\DataTypeTok{V}\NormalTok{ [}\DataTypeTok{A}\NormalTok{, }\DataTypeTok{B}\NormalTok{] }\DataTypeTok{Price} 
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share} 
\NormalTok{    messages }\DataTypeTok{B}\NormalTok{ [}\DataTypeTok{A}\NormalTok{, }\DataTypeTok{V}\NormalTok{] }\DataTypeTok{Ok} 
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{C} \DataTypeTok{Share}
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{C} \DataTypeTok{Thunk}
\NormalTok{    message }\DataTypeTok{B} \DataTypeTok{V} \DataTypeTok{Address}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Date}
\NormalTok{    end}
\end{Highlighting}
\end{Shaded}



\subsection{A Reversible Semantics}\label{a-reversible-semantics}
Having shown  implementations for processes and global types, we now explain how to implement the  reversible operational semantics
for the MP model, which was illustrated in \secref{ss:exam}.
We should define structures that allow us to move back to prior program states, reversing forward
steps.

To enable backward steps, we need to store some information when we move forward, just as enabled by the configurations in the MP model (cf. \secref{ss:processes}).
Indeed, we need to track information about the local type and the process.
For the local type, we define a data type called \texttt{TypeContext}: it
contains the actions that have been performed; for some of them, it also
stores extra information (e.g., \texttt{owner}).
For the process, there are four things that we need to track:

\begin{enumerate}[1.]
\def\labelenumi{\arabic{enumi}.}
\item \emph{Used variable names in receives}.
    Recall the process implementation for  the vendor in the three-buyer example in \secref{ss:exam}:
  \begin{align*}
  \text{Vendor} & =  \bout{d}{x:\tproj{G}{\pS}}\binp{x}{t}\bout{x}{price(t)}\bout{x}{price(t)} \binp{x}{ok}\binp{x}{a} \bout{x}{date}\inact
  \end{align*}

We can implement this process as:
\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{vendor ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{vendor }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    t }\OtherTok{<-}\NormalTok{ H.receive }
\NormalTok{    H.send (price t) }
\NormalTok{    H.send (price t) }
    \FunctionTok{...}
\NormalTok{    terminate}
\end{Highlighting}
\end{Shaded}
  The rest of the program depends on the assigned name. So, e.g.,
  when we evaluate the \texttt{t\ \textless{}-\ H.receive} line
  (moving to configuration \(M_3\), cf.~\secref{ss:exam}), and then revert it, we must
  reconstruct a receive that assigns to \texttt{t}, because the
  following lines depend on   name \texttt{t}. \\

\item \emph{Function calls and their arguments}.
      Consider the reduction from configuration $M_7$ to $M_8$, as discussed in \secref{ss:exam}. Once the thunk
  is evaluated, producing configuration \(M_8\), we lose all evidence that the
  code produced by the evaluation  resulted from a function
  application. 
  Without this evidence, reversing $M_8$ will
  not result in $M_7$. Indeed, we need to keep track of function
  applications. 
  Following the semantics of the MP model, 
  the function and its argument are stored in a map
  indexed by a unique identifier $k$. The identifier $k$ itself is also
  stored in the local type with history to later associate the type with
  a specific function and argument.
  The reduction from $M_8$ to $M_9$, discussed in \secref{ss:exam}, offers an example of this tracking mechanism in the formal model.

 Notice that a stack would seem a simpler solution, but it
  can give invalid behavior. Say that a participant is running in two
  locations, and the last-performed action at both locations is a
  function application. Now we want to undo both applications, but the
  order in which to undo them is undefined: we need both orders to work.
  Only using a stack could mix up the applications. When the application
  keeps track of exactly which function and argument it used the end
  result is always the same.  \\
  
\item \emph{Messages on the channel}.
    We consider again the implementation of the first three steps of the protocol:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{alice ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{alice }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    H.send (}\DataTypeTok{VString} \StringTok{"Logicomix"}\NormalTok{ )}
    \FunctionTok{...}
\OtherTok{vendor ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{vendor }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    t }\OtherTok{<-}\NormalTok{ H.receive }
    \FunctionTok{...}
\end{Highlighting}
\end{Shaded}

  After Alice sends her message, this message has to be stored to successfully undo the sending action.
  Likewise, when starting from configuration $M_3$ and undoing the receive,
  the value must be placed back into the queue. 

  \checkthis{Our implementation closely follows the formal semantics of the MP model. 
  As discussed in \secref{ss:processes}, the message queue has an input and an output part.
  This  
  allows to describe how a message moves from the sender into the
  output queue. Reception is represented by moving the message  to the input queue, which serves as a
  history stack.  
  {When the receive is reversed}, the queue pops the message
  from its stack and puts it at the output queue again. Reversing
  the send moves the message from the output queue  back to
  the sender's program}. \\
  
\item \emph{Unused branches}.
  When a labeled choice is made and then reverted, we want all our options to be
  available again. In the MP model, choices made so far are stored in a stack denoted $\stack C$, inside a running process (cf. \secref{ss:processes}). % $\np{\ep{\loc}{\p}}{\conf{\stack C}{P}}$.
  
%  Currently, another label cannot actually be selected
%  after reverting: the selected label depends only on the values of
%  variables in the program. Future work may make it possible to also use
%  the failure information to influence  choices made.
  
   The following code shows how we store these choices:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Zipper}\NormalTok{ a }\FunctionTok{=}\NormalTok{ (}\NormalTok{[a], a, [a])}

\KeywordTok{data} \DataTypeTok{OtherOptions}
    \FunctionTok{=} \DataTypeTok{OtherSelections}\NormalTok{ (}\DataTypeTok{Zipper}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Value}\NormalTok{, }\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{))}
    \FunctionTok{|} \DataTypeTok{OtherOffers}\NormalTok{ (}\DataTypeTok{Zipper}\NormalTok{ (}\DataTypeTok{String}\NormalTok{, }\DataTypeTok{Program} \DataTypeTok{Value}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

  We need to remember
  which choice was made; the order of the options is important. We
  use a \texttt{Zipper} to store the elements in order and use the
  central `\texttt{a}' to store the choice that was made.
\end{enumerate}
  % Fig.  \ref{fig:reverse-send-receive} below illustrates this process:

%  \begin{figure}[h!]
%  \begin{align*}
%  \includegraphics[scale=0.60]{img/queue-history-stack.pdf}
%  \end{align*}
%  \caption{Reversal of send and receive}
%  \label{fig:reverse-send-receive}
%  \end{figure}

%   \begin{enumerate}
%   \def\labelenumii{\arabic{enumii}.}
%   \tightlist
%   \item
%     \textbf{receive}: the value 42 is popped from the queue but pushed
%     onto the history stack.
%   \item
%     \textbf{roll receive}: Now when the receive is rolled, the value is
%     moved back from the history stack onto the queue.
%   \item
%     \textbf{roll send}: When the send is rolled the value is moved from
%     the head of the queue into the sender's process.
%   \end{enumerate}
% \end{enumerate}




\subsection{Putting it all together}\label{combining}
With all the definitions in place, we can now define the forward and backward
evaluation of our system. 
The reduction relations \fw and \bk, discussed and illustrated in \secref{ss:exam}, are implemented with the types:
\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{forward  ::} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{Session}\NormalTok{ ()}
\OtherTok{backward ::} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{Session}\NormalTok{ ()}
\end{Highlighting}
\end{Shaded}

These functions take a \texttt{Location} (our way of modeling different
threads or machines) and try to move the process at that location
forward or backward. The \texttt{Session} type contains the
\texttt{ExecutionState}, the state of the session (all programs, local
types, variable bindings, etc.). The \texttt{Except} type indicates that errors of type \texttt{Error} can be thrown, for instance when an unbound variable is used:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Session}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{StateT} \DataTypeTok{ExecutionState}\NormalTok{ (}\DataTypeTok{Except} \DataTypeTok{Error}\NormalTok{) a}
\end{Highlighting}
\end{Shaded}
%({See also Appendices \ref{state} on \texttt{StateT} and \ref{except} on \texttt{Except}.)

The 
configurations of the MP model ({cf. \secref{ss:processes})
are our main reference to store the execution
state. Some data is bound to its location (e.g., the current running process), while other data is bound to its participant (e.g., the
local type).
The information about a participant is grouped in a type called
\texttt{Monitor}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Monitor}\NormalTok{ value tipe }\FunctionTok{=} 
    \DataTypeTok{Monitor} 
\NormalTok{        \{}\OtherTok{ _localType ::} \DataTypeTok{LocalTypeState}\NormalTok{ tipe}
\NormalTok{        ,}\OtherTok{ _recursiveVariableNumber ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ _recursionPoints ::} \NormalTok{[}\DataTypeTok{LocalType}\NormalTok{ tipe]}
\NormalTok{        ,}\OtherTok{ _usedVariables ::} \NormalTok{[}\DataTypeTok{Binding}\NormalTok{]}
\NormalTok{        ,}\OtherTok{ _applicationHistory ::} \DataTypeTok{Map} \DataTypeTok{Identifier}\NormalTok{ (value, value)}
\NormalTok{        ,}\OtherTok{ _store ::} \DataTypeTok{Map} \DataTypeTok{Identifier}\NormalTok{ value }
\NormalTok{        \}}
        \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{)}

\KeywordTok{data} \DataTypeTok{Binding} \FunctionTok{=} 
    \DataTypeTok{Binding} 
\NormalTok{        \{}\OtherTok{ _visibleName ::} \DataTypeTok{Identifier}
\NormalTok{        ,}\OtherTok{ _internalName ::} \DataTypeTok{Identifier} 
\NormalTok{        \}}
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Show}\NormalTok{, }\DataTypeTok{Eq}\NormalTok{) }
\end{Highlighting}
\end{Shaded}
Some explanations follow:
\begin{itemize}
\item
  \texttt{\_localType} contains \texttt{TypeContext} and
  \texttt{LocalType} stored as a tuple. This tuple gives a cursor into
  the local type, where everything to the left is the past and
  everything to the right is the future.
\item
  The next two fields keep track of recursion in the local
  type. We use the \texttt{\_recursiveVariableNumber} is an index into the
  \texttt{\_recursionPoints} list: when a \texttt{RecursionVariable} is
  encountered we look at that index to find the new future local type.
\item
  \texttt{\_usedVariables} and \texttt{\_applicationHistory} are used in
  reversal. As mentioned in \secref{a-reversible-semantics}, used
  variable names must be stored so we can use them when
  reversing. We store them in a stack keeping both the original name
  given by the programmer and the generated unique internal name. For
  function applications we use a \texttt{Map} indexed by unique
  identifiers that stores function and argument.
\item
   \texttt{\_store} is a variable store with the currently
  defined bindings. Variable shadowing (when two processes of the same
  participant define the same variable name) is not an issue: 
  variables are assigned a name that is guaranteed unique.
\end{itemize}

\noindent We can now define \texttt{ExecutionState}: it contains some counters for
generating unique variable names, a monitor for every participant, and a
program for every location. Additionally, every location has a default
participant and a stack for unchosen branches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ExecutionState}\NormalTok{ value }\FunctionTok{=} 
    \DataTypeTok{ExecutionState} 
\NormalTok{        \{}\OtherTok{ variableCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ locationCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ applicationCount ::} \DataTypeTok{Int}
\NormalTok{        ,}\OtherTok{ participants ::} \DataTypeTok{Map} \DataTypeTok{Participant}\NormalTok{ (}\DataTypeTok{Monitor}\NormalTok{ value }\DataTypeTok{String}\NormalTok{)}
\NormalTok{        ,}\OtherTok{ locations ::} \DataTypeTok{Map} \DataTypeTok{Location} 
\NormalTok{                 (}\DataTypeTok{Participant}\NormalTok{ , [}\DataTypeTok{OtherOptions}\NormalTok{], }\DataTypeTok{Program}\NormalTok{ value)}
\NormalTok{        ,}\OtherTok{ queue ::} \DataTypeTok{Queue}\NormalTok{ value}
\NormalTok{        ,}\OtherTok{ isFunction ::}\NormalTok{ value }\OtherTok{->} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Identifier}\NormalTok{, }\DataTypeTok{Program}\NormalTok{ value)}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}
\noindent
The message queue is global and thus also lives in the
\texttt{ExecutionState}. Finally, we need a way of inspecting values, to
see whether they are functions and if so, to extract their bodies for
application.

\subsection{Causal Consistency?}\label{properties-of-reversibility}
As mentioned in \secref{s:intro}, causal consistency is a key correctness criterion for a reversible semantics: this property ensures that backward steps always lead to states that 
could have been reached by moving forward only.
The global type defines a partial order on all the communication steps.
The relation of this partial order is a causal dependency. Stepping
backward is only allowed when all its causally dependent actions are
undone. 

The reversible semantics of the MP model, summarized in \secref{the-process-model}, enjoys causal consistency
for processes running a single global protocol (i.e., a single session). 
Rather than typed processes, the MP model describes \emph{untyped} processes whose (reversible) operational semantics is governed by local types. 
This suffices to prove causal consistency, but also to ensure that process reductions correspond to valid actions specified by the global type. 
Given this, one may then wonder, does our Haskell implementation preserve causal consistency? 



In the semantics and the implementation, this causal dependency becomes a data dependency. 
For instance, a send can only be undone only when the queue is in a state that can only be reached by first undoing the corresponding receive.
Only in this state the appropriate data  of the appropriate type is available.
Being able to undo a send thus means that the corresponding receive has already been reversed, so it is impossible to introduce causal inconsistencies. 

Because of the encoding of causal dependencies as data dependencies, and the fact that these data dependencies are preserved in the implementation,  
we claim that our Haskell implementation respects the formal semantics of the MP model, and therefore that it preserves the causal consistency property.


\section{Running and Debugging Programs}\label{running-debugging}

Finally, we want to be able to run our programs. Our implementation
offers mechanisms to step through a program interactively, and run it to
completion.

We can step through the program interactively in the Haskell REPL
environment. 
When the \texttt{ThreeBuyer} example is loaded, the program is in a state corresponding to configuration $M_1$ from  \secref{ss:exam}.
We can print the initial state of our program:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ initialProgram}
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Send}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Next we introduce the \texttt{stepForward} and \texttt{stepBackward}
functions. They use mutability, normally frowned upon in Haskell, to
avoid having to manually keep track of the updated program state like in
the snippet below:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{state1 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state0}
\NormalTok{state2 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state1}
\NormalTok{state3 }\FunctionTok{=}\NormalTok{ stepForwardInconvenient }\StringTok{"l1"}\NormalTok{ state2}
\end{Highlighting}
\end{Shaded}

Manual state passing is error-prone and inconvenient. We provide helpers
 to work around this issue (internally, those helpers use \texttt{IORef}). We must
first initialize the program state:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>} \KeywordTok{import }\DataTypeTok{Interpreter}
\FunctionTok{>}\NormalTok{ state }\OtherTok{<-}\NormalTok{ initializeProgram initialProgram}
\end{Highlighting}
\end{Shaded}

\noindent We can then use \texttt{stepForward} and \texttt{stepBackward} to
evaluate the program: we advance Alice at $l_1$ to reach   $M_2$ and then the vendor at $l_4$ to reach  $M_3$:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l1"}\NormalTok{ state}
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Receive}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l4"}\NormalTok{ state }
\NormalTok{locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{Receive}\NormalTok{ \{owner }\FunctionTok{=} \StringTok{"A"}\NormalTok{, }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

When the user tries an invalid step, an error is displayed. For instance,
in state $M_3$, where \(l_1\) and \(l_4\) have been moved forward once (like in the
snippet above), \(l_1\) cannot move forward (it needs to receive but
there is nothing in the queue) and not backward (\(l_4\), the receiver,
must undo its action first).

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ stepForward }\StringTok{"l1"}\NormalTok{ state}
\FunctionTok{***} \DataTypeTok{Exception}\FunctionTok{:} \DataTypeTok{QueueError} \StringTok{"Receive"} \DataTypeTok{EmptyQueue}
\DataTypeTok{CallStack}\NormalTok{ (from }\DataTypeTok{HasCallStack}\NormalTok{)}\FunctionTok{:}
\NormalTok{  error, called at }\FunctionTok{...} 
\FunctionTok{>}\NormalTok{ stepBackward }\StringTok{"l1"}\NormalTok{ state}
\FunctionTok{***} \DataTypeTok{Exception}\FunctionTok{:} \DataTypeTok{QueueError} \StringTok{"BackwardSend"} \DataTypeTok{EmptyQueue}\NormalTok{ state}
\DataTypeTok{CallStack}\NormalTok{ (from }\DataTypeTok{HasCallStack}\NormalTok{)}\FunctionTok{:}
\NormalTok{  error, called at }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Errors are defined as:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Error} 
    \FunctionTok{=} \DataTypeTok{UndefinedParticipant} \DataTypeTok{Participant}
    \FunctionTok{|} \DataTypeTok{UndefinedVariable} \DataTypeTok{Participant} \DataTypeTok{Identifier}
    \FunctionTok{|} \DataTypeTok{SynchronizationError} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{LabelError} \DataTypeTok{String}
    \FunctionTok{|} \DataTypeTok{QueueError} \DataTypeTok{String} \DataTypeTok{Queue.QueueError}
    \FunctionTok{|} \DataTypeTok{ChoiceError} \DataTypeTok{ChoiceError}
    \FunctionTok{|} \DataTypeTok{Terminated}
\end{Highlighting}
\end{Shaded}

To fully evaluate a program, we use a round-robin scheduler that calls
\texttt{forward} on the locations in order. A forward step can produce
an error. There are two error cases that we can recover from:

\begin{itemize}
\item
  \textbf{blocked on receive}, either
  \texttt{QueueError\ \_\ InvalidQueueItem} or
  \texttt{QueueError\ \_\ EmptyQueue}: the process wants to perform a
  receive, but the expected item is not at the top of the queue yet. In
  this case we proceed evaluating the other locations so they
  can send the value that the faulty location expects. Above, `\texttt{\_}'
    means that we ignore the \texttt{String} field
   used to provide better error messages. Because no error
  message is generated, that field is not needed.
\item
  \textbf{location terminates} with \texttt{Terminated}: the execution
  has reached a \texttt{NoOp}. In this case we do not want to schedule
  this location any more.
\end{itemize}

\noindent Otherwise we continue until there are no active (non-terminated)
locations left. 

Running until completion (or error) is also available in the REPL:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{>}\NormalTok{ untilError initialProgram}
\DataTypeTok{Right}\NormalTok{ locations}\FunctionTok{:}\NormalTok{ fromList [(}\StringTok{"l1"}\NormalTok{,(}\StringTok{"A"}\NormalTok{,[],}\DataTypeTok{Free} \DataTypeTok{NoOp}\NormalTok{)), }\FunctionTok{...} 
\end{Highlighting}
\end{Shaded}

Note that this scheduler can still get into deadlocks, for instance
consider these two equivalent global types:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{globalType1 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Price}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{A} \DataTypeTok{Price}
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share}

\NormalTok{globalType2 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{V} \DataTypeTok{Title}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{A} \DataTypeTok{Price}
\NormalTok{    message }\DataTypeTok{V} \DataTypeTok{B} \DataTypeTok{Price}
\NormalTok{    message }\DataTypeTok{A} \DataTypeTok{B} \DataTypeTok{Share}
\end{Highlighting}
\end{Shaded}
\noindent
Above, the second and third messages (involving \texttt{\DataTypeTok{Price}}) are swapped. The communication they describe
is the same, but in practice they are very different. The first example will
run to completion, whereas the second can deadlock because \texttt{A} can
send a \texttt{Share} before \texttt{V} sends the \texttt{Price}. \texttt{B} expects the
price from \texttt{V} first, but the share from \texttt{A} is the first
in the queue. Therefore, no progress can be made.


\section{Discussion and Concluding Remarks}\label{discussion}

\subsection{Benefits of pure functional programming}\label{benefits-of-pure-functional-programming}

It has consistently been the case that sticking closer to the formal
model gives better code. The abilities that Haskell gives for directly
specifying formal statements are invaluable. A key invaluable
feature is algebraic data types (ADTs, also known as tagged unions or
sum types). Compare the formal definition 
given in \secref{ss:types}
and the Haskell data type for global
types.
\begin{align*}
    G, G'  \bnfis & \gtcom{p}{q}{U}{G} %\bnfbar 
    \sbnfbar
    \gtcho{p}{q}{\lbl_i}{G_i} %\\
    \sbnfbar %& 
    \mu X. G \sbnfbar X \sbnfbar \gend 
\end{align*}


\footnotesize
\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{GlobalTypeF}\NormalTok{ u next }
    \FunctionTok{=} \DataTypeTok{Transaction}\NormalTok{ \{}\FunctionTok{..}\NormalTok{\} }\FunctionTok{|} \DataTypeTok{Choice}\NormalTok{ \{}\FunctionTok{..}\NormalTok{\}  }\FunctionTok{|} \DataTypeTok{RecursionPoint}\NormalTok{ next }\FunctionTok{|} \DataTypeTok{RecursionVariable} \FunctionTok{|} \DataTypeTok{End} 
    \FunctionTok{|} \DataTypeTok{WeakenRecursion}\NormalTok{ next}
\end{Highlighting}
\end{Shaded}

\normalsize 

The definitions correspond directly. Moreover, we know that these are
all the ways to construct a value of type \texttt{GlobalTypeF} and can
exhaustively match on all the cases. Functional languages have had these
features for a very long time. 
%In recent years they have also made their way into non-functional languages (Rust, Swift, Kotlin).
Secondly, purity and immutability are very useful in implementing and
testing the reversible semantics. 
% The data types help with reversing in the correct order by making intermediate reversed states impossible to represent.  
% \modi{The type system can actually guarantee that we have not forgotten to revert anything.}

In a pure language, given functions
\texttt{f\ ::\ a\ -\textgreater{}\ b} and
\texttt{g\ ::\ b\ -\textgreater{}\ a} to prove that \(f\) and \(g\) are
inverses it is enough to prove 
%(or to test for the domain you'reinterested in) 
that
%\begin{verbatim}
%f . g = identity && g . f = identity
%\end{verbatim}
$\mathtt{f} \cdot \mathtt{g}$ and  $\mathtt{g} \cdot \mathtt{f}$ both compose to the identity.
In an impure language, even if these equalities are observed we
cannot be sure that there were no side-effects. Because we do not need
to consider a context (the outside world) in a pure language, checking that
reversibility works is as simple as comparing initial and final states
for all backward reduction rules.


%\paragraph{Future Work.}\label{concurrent-debuggers}
%
%As mentioned we initially also set out to investigate how useful PPDP
%semantics are for debugging concurrent programs. As it stands, there are
%two missing features
%
%\begin{enumerate}
%\def\labelenumi{\arabic{enumi}.}
%\item
%  Modifying concurrent control flow
%
%  That is, a way to specify which thread will (try to) take a step
%  forward next. The problem with concurrency is not so much technical:
%  the primitives are available. What is needed is some way to step
%  through a program one instruction at a time. The real challenge is
%  providing a convenient mechanism for doing so.
%\item
%  Convenient user interface
%
%  CaReDeb provides a command line interface. While CaReDeb is
%  interesting from a technical point of view, its interface is not
%  convenient. Additionally, the overhead of bringing the problem into
%  CaReDeb's language is large: more time is probably spent translating
%  than actually debugging.
%
%  We think that a good graphical interface is possible, but besides
%  technical features a good user experience also needs user feedback.
%  This means that we need to look for users and concrete use cases. It
%  would help if there were some concrete set of problems that could be
%  extracted from code, compiled into a format/language that our debugger
%  understands and then visually debugged. Performance can then be
%  evaluated based on how well the debugger solves real-world problems.
%\end{enumerate}


\subsection{Concluding Remarks}\label{conclusion}

We have given a functional implementation of the (reversible) MP model~\cite{DBLP:conf/ppdp/MezzinaP17} using the Haskell
programming language. By embedding this reversible semantics we can now run and
verify our example programs automatically and inspect them
interactively.

We have seen that the MP model can be split into three core components: (i)~a process calculus, (ii)~multiparty
session types (global and local types), and (iii)~forward and backward reduction semantics. The three components can be cleanly represented as recursive Haskell data types. We are confident that other features developed in Mezzina and P\'{e}rez's work~\cite{DBLP:conf/ppdp/MezzinaP17} (in particular, an alternative semantics for decoupled rollbacks)
can easily be integrated in the development described here.
Relatedly, the implementation process has shown that sticking to the
formal model leads to better code; there is less space for bugs
to creep in. Furthermore, Haskell's mathematical nature means that the
implementation inspired by the formal specification is easy (and often
idiomatic) to express.
Finally, we have discussed how Haskell allows for the definition of flexible embedded
domain-specific languages, and makes it easy to transform between
different representations of our programs (using among others \texttt{Monad.Free}).








\paragraph{\textbf{Acknowledgments.}} 
This research has been partially supported by 
%the Undergratudate School of Science and the Bernoulli Institute of the University of Groningen. We also acknowledge support from the 
COST Action IC1405 ``Reversible computation -- Extending horizons of computing''.

%The work in this thesis has been presented at the TFP'18 conference in
%Gothenburg, Sweden. Attending the conference was made possible by
%financial support from the , for which we are extremely grateful

\bibliographystyle{abbrv}
%\bibliography{biblio}
\bibliography{session,biblio}

\end{document}

%\pagebreak
\newpage

\appendix

\section{Appendix}\label{appendix}

%Background information on Haskell syntax and concepts used in the thesis.


\subsection{Convenient Syntax with the Free Monad}\label{free-monad-dsl}

The types we have defined for \texttt{Program}, \texttt{GlobalType} and
\texttt{LocalType} form recursive tree structures. Because they are all
new types, there is no easy way to traverse them. A common idiom is to
factor out recursion using \texttt{Data.Fix} (see Appendix
\ref{factoring-recursion}).

While a \texttt{Fix}ed data type is easy to manipulate and traverse, it
can be messy to write. The program below implements ``receive and bind
the value to \texttt{result}, then send 42'':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{program }\FunctionTok{=}  
    \DataTypeTok{Fix} 
\NormalTok{        ( }\DataTypeTok{Receive} 
\NormalTok{            \{ owner }\FunctionTok{=} \StringTok{"Alice"}
\NormalTok{            , variableName }\FunctionTok{=} \StringTok{"result"}
\NormalTok{            , continuation }\FunctionTok{=} 
                  \DataTypeTok{Fix} 
\NormalTok{                    ( }\DataTypeTok{Send} 
\NormalTok{                        \{ owner }\FunctionTok{=} \StringTok{"Alice"}
\NormalTok{                        , value }\FunctionTok{=} \DataTypeTok{VInt} \DecValTok{42}
\NormalTok{                        , continuation }\FunctionTok{=} \DataTypeTok{Fix} \DataTypeTok{NoOp} 
\NormalTok{                        \}}
\NormalTok{                    )}
\NormalTok{              \}}
\NormalTok{        )}
\end{Highlighting}
\end{Shaded}

The syntax distracts from the goal of the program. \texttt{Program} and
\texttt{GlobalType} are types that we will write a lot manually, so
fixing this issue is important.

Conveniently, Haskell has a long tradition of embedded domain-specific
languages. In particular we can use a cousin of \texttt{Fix}, the
\texttt{Free} monad (Appendix~\ref{free-monad}) to get access to
do-notation (Appendix \ref{do-notation}). Concretely, the do-notation
makes it possible instead of the above write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{program }\FunctionTok{=}\NormalTok{ compile }\StringTok{"Alice"} \FunctionTok{$} \KeywordTok{do}
\NormalTok{    result }\OtherTok{<-}\NormalTok{ receive}
\NormalTok{    send (}\DataTypeTok{VInt} \DecValTok{42}\NormalTok{)}
\NormalTok{    terminate}
\end{Highlighting}
\end{Shaded}

\noindent
Behind the scenes, the do-notation produces a value of type
\texttt{HighLevelProgram\ a} using some helpers like \texttt{send} and
\texttt{terminate}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{HighLevelProgram}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{HighLevelProgram} 
\NormalTok{    (}\DataTypeTok{StateT}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{) (}\DataTypeTok{Free}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{)) a)}
    \KeywordTok{deriving} 
\NormalTok{        ( }\DataTypeTok{Functor}\NormalTok{, }\DataTypeTok{Applicative}\NormalTok{, }\DataTypeTok{Monad}
\NormalTok{        , }\DataTypeTok{MonadState}\NormalTok{ (}\DataTypeTok{Participant}\NormalTok{, }\DataTypeTok{Int}\NormalTok{)}
\NormalTok{        , }\DataTypeTok{MonadFree}\NormalTok{ (}\DataTypeTok{ProgramF} \DataTypeTok{Value}\NormalTok{)}
\NormalTok{        )}

\OtherTok{send ::} \DataTypeTok{Value} \OtherTok{->} \DataTypeTok{HighLevelProgram}\NormalTok{ ()}
\NormalTok{send value }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    (participant, _) }\OtherTok{<-}\NormalTok{ State.get}
\NormalTok{    liftF (}\DataTypeTok{Send}\NormalTok{ participant value ())  }

\OtherTok{terminate ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{terminate }\FunctionTok{=}\NormalTok{ liftF }\DataTypeTok{NoOp}

\CommentTok{-- similar for receive, select, etc.}
\end{Highlighting}
\end{Shaded}

The above snippet introduces some new Haskell concepts that require some
background. Pure languages can simulate mutable state using a type
called \texttt{State} (Appendix \ref{state}). \texttt{State} is an
instance of monad (Appendix \ref{monads}) which makes it easy to chain
stateful computations. In this case our piece of state is a pair
\texttt{(Participant,\ Int)}: the participant is the owner of the block,
and the \texttt{Int} is a counter used to generate unique variable
names. To combine \texttt{State} with \texttt{Free} (and to combine two
monads in general) we need the \texttt{StateT} monad transformer
(Appendix \ref{state}).

In the \texttt{send} helper we use the unit type \texttt{()} as a
placeholder or hole. A continuation will need to fill the hole
eventually but it is not available yet. When a \texttt{HighLevelProgram}
is converted into a \texttt{Program}, we want to be sure there are no
remaining holes. In this particular case that means all branches must
end in \texttt{terminate}. We use the fact that
\texttt{terminate\ ::\ HighLevelProgram\ a} contains a free type
variable \texttt{a} which can unify with \texttt{Void}, the type with no
values. Thus \texttt{Free\ f\ Void} can contain no \texttt{Pure} because
the \texttt{Pure} constructor needs a value of type \texttt{Void}, which
don't exist. For more information, see Appendix~\ref{well-formedness-free}.


\subsection{Installing and Running}\label{installing-and-running}

This project is written in Haskell and built with its \emph{stack} build
tool. Stack can be downloaded from
\href{https://docs.haskellstack.org/en/stable/README/}{here}. The next
step is to clone the repository, which is
\href{https://github.com/folkertdev/reversible-debugger}{available on
github}.

The snippet below will clone the repository (assumes ssh is set up) and
build it. This can take a while because it also has to download and
install the Haskell GHC compiler.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{git}\NormalTok{ clone git@github.com:folkertdev/reversible-debugger.git}
\BuiltInTok{cd}\NormalTok{ reversible-debugger}
\ExtensionTok{stack}\NormalTok{ build}
\end{Highlighting}
\end{Shaded}

Finally we can load an example program in the REPL:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{stack}\NormalTok{ ghci }\CommentTok{# opens the interactive environment}
\NormalTok{:}\ExtensionTok{l}\NormalTok{ src/Examples/ThreeBuyer.hs }\CommentTok{# loads the example}
\end{Highlighting}
\end{Shaded}

\subsection{Performing IO in Haskell}\label{performing-io}

One of Haskell's key characteristics is that it is pure. This means that
our computations cannot have any observable effect to the outside world.
Purity enables us to reason about our programs (referential
transparency) and enables compiler optimizations.

But we use computers to solve problems, and we want to be able to
observe the solution to our problems. Pure programs cannot produce
observable results: the computer becomes very hot but we cannot see our
solutions.

So we perform a trick: we say that constructing our program is
completely pure, but evaluating may produce side-effects like printing
to the console or writing to a file. To separate this possibly effectful
code from pure code we use the type system: side-effects are wrapped in
the \texttt{IO} type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{-- print a string to the console}
\NormalTok{putStrLn}\OtherTok{ ::} \DataTypeTok{String} \OtherTok{->} \DataTypeTok{IO}\NormalTok{ ()}

\CommentTok{-- read a line of input from the console}
\NormalTok{readLn}\OtherTok{ ::} \DataTypeTok{IO} \DataTypeTok{String}
\end{Highlighting}
\end{Shaded}

A consequence of having no observable effects is that the compiler can
reorder our code for faster execution (e.g., by minimizing cache
misses). But this will wreak havoc when performing IO: we want our IO
actions to absolutely be ordered.

The trick we can pull here is to wrap the later actions in a function
taking one argument, and piping the result of the first action into that
function. The result is only available when the first action is done, so
the first action is always performed before the rest: we have
established a data-dependency between the first and the remaining
actions that enforces the order.

The piping is done by the \texttt{\textgreater{}\textgreater{}=}
operator. In the Haskell literature this function is referred to as
\texttt{bind}, but I think the elm name \texttt{andThen} is more
intuitive (at least for \texttt{IO}). A program that first reads a line
and then prints it again can be written as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\FunctionTok{=} 
\NormalTok{    readLn }\FunctionTok{>>=}\NormalTok{ (\textbackslash{}line }\OtherTok{->}\NormalTok{ putStrLn line)}

\OtherTok{andThen ::} \DataTypeTok{IO}\NormalTok{ a }\OtherTok{->}\NormalTok{ (a }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ b) }\OtherTok{->} \DataTypeTok{IO}\NormalTok{ b}
\NormalTok{andThen }\FunctionTok{=}\NormalTok{ (}\FunctionTok{>>=}\NormalTok{)}

\NormalTok{main2 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    readLn }\OtherTok{`andThen`}\NormalTok{ (\textbackslash{}line }\OtherTok{->}\NormalTok{ putStrLn line)}
\end{Highlighting}
\end{Shaded}

The \texttt{putStrLn} can only be evaluated when \texttt{line} is
available, so after \texttt{readLn} is done. More technically the
\texttt{(\textgreater{}\textgreater{}=)\ ::\ IO\ a\ -\textgreater{}\ (a\ -\textgreater{}\ IO\ b)\ -\textgreater{}\ IO\ b}
operator will first evaluate its first argument \texttt{IO\ a}, in this
case \texttt{IO\ String} (that string is the line we have read). Then it
``unwraps'' that \texttt{IO\ String} to \texttt{String} to give it as an
argument to \texttt{a\ -\textgreater{}\ IO\ b} (here
\texttt{String\ -\textgreater{}\ IO\ ()}). Note that we can never
(safely) go from \texttt{IO\ a\ -\textgreater{}\ a}. The unwrapping here
is only valid because the final return type is still
\texttt{IO\ something}.

When printing two lines, we can use a similar trick to force the order

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main }\FunctionTok{=} 
\NormalTok{    putStrLn }\StringTok{"hello "} \FunctionTok{>>=}\NormalTok{ (\textbackslash{}_ }\OtherTok{->}\NormalTok{ putStrLn }\StringTok{"world"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here we ignore the result of the first \texttt{putStrLn}, but the second
\texttt{putStrLn} still depends on its return value. Thus it has to wait
for the first \texttt{putStrLn} to finish before it can start.

\subsection{Do-notation}\label{do-notation}

Writing nested functions in this way quickly becomes tedious. That is
why special syntax is available: do-notation

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{main1 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    line }\OtherTok{<-}\NormalTok{ readLn}
\NormalTok{    putStrLn line}

\NormalTok{main2 }\FunctionTok{=} \KeywordTok{do}
\NormalTok{    putStrLn }\StringTok{"hello "}
\NormalTok{    putStrLn }\StringTok{"world"}
\end{Highlighting}
\end{Shaded}

do-notation is only syntactic sugar: it is translated by the compiler to
the nested functions that we have seen above. The syntax is very
convenient however. Additionally, we can use it for all types that
implement \texttt{\textgreater{}\textgreater{}=}: all instances of the
\texttt{Monad} typeclass.

\subsection{Monads}\label{monads}

\texttt{Monad} is a Haskell typeclass (and a concept from a branch of
mathematics called category theory). Typeclasses are sets of types that
implement some functions, similar to interfaces or traits in other
languages.

The monad typeclass defines two methods:
bind/andThen/\texttt{\textgreater{}\textgreater{}=} which we have seen
and
\texttt{return\ ::\ Monad\ m\ =\textgreater{}\ a\ -\textgreater{}\ m\ a}.
The \texttt{Monad\ m\ =\textgreater{}} part of the signature constrains
the function to only work on types that have a \texttt{Monad} instance.

The above should already give some intuition about monad's main
operator \texttt{\textgreater{}\textgreater{}=}: it forces order of
evaluation. A second property is that \texttt{Monad} can merge contexts
with
\texttt{join\ ::\ Monad\ m\ =\textgreater{}\ m\ (m\ a)\ -\textgreater{}\ m\ a}.
A common example of join is
\texttt{List.concat\ ::\ List\ (List\ a)\ -\textgreater{}\ List\ a}. A
bit more illustrative is the implementation for \texttt{Maybe}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{join ::} \DataTypeTok{Maybe}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ a) }\OtherTok{->} \DataTypeTok{Maybe}\NormalTok{ a}
\NormalTok{join value }\FunctionTok{=} 
    \KeywordTok{case}\NormalTok{ value }\KeywordTok{of} 
        \DataTypeTok{Nothing} \OtherTok{->} 
            \DataTypeTok{Nothing}

        \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{Nothing}\NormalTok{) }\OtherTok{->} 
            \DataTypeTok{Nothing}

        \DataTypeTok{Just}\NormalTok{ (}\DataTypeTok{Just}\NormalTok{ x) }\OtherTok{->} 
            \DataTypeTok{Just}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

If the outer context has failed (is \texttt{Nothing}), then the total
computation has failed and there is no value of type \texttt{a} to give
back. If the outer computation succeeded but the inner one failed, there
is still no \texttt{a} and the only thing we can return is
\texttt{Nothing}. Only if both the inner and the outer computations have
succeeded can we give a result back.

In short:

\begin{itemize}
\tightlist
\item
  \texttt{Monad} is a Haskell typeclass
\item
  it has two main functions

  \begin{itemize}
  \tightlist
  \item
    bind or andThen or
    \texttt{\textgreater{}\textgreater{}=\ ::\ Monad\ m\ =\textgreater{}\ m\ a\ -\textgreater{}\ (a\ -\textgreater{}\ m\ b)\ -\textgreater{}\ m\ b}
  \item
    \texttt{return\ ::\ Monad\ m\ =\textgreater{}\ a\ -\textgreater{}\ m\ a}
  \end{itemize}
\item
  \texttt{Monad} forces the order of operations and can flatten wrappers
\item
  \texttt{Monad} allows us to use do-notation
\item
  \texttt{IO} is an instance of \texttt{Monad}
\end{itemize}

Much material on the web about monads is about establishing the general
idea, but really the exact meaning of
\texttt{\textgreater{}\textgreater{}=} can be very different for every
instance. Next we will look at some of the types used in the code for
this project.

\subsection{Except}\label{except}

Except is very similar to \texttt{Either}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Either}\NormalTok{ a b }
    \FunctionTok{=} \DataTypeTok{Left}\NormalTok{ a }
    \FunctionTok{|} \DataTypeTok{Right}\NormalTok{ b}
\end{Highlighting}
\end{Shaded}

We use this type to throw and track errors in a pure way.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{throwError ::}\NormalTok{ e }\OtherTok{->} \DataTypeTok{Except}\NormalTok{ e a}

\KeywordTok{data} \DataTypeTok{Error}
    \FunctionTok{=} \DataTypeTok{QueueEmpty}
    \FunctionTok{|} \FunctionTok{...}
    
\OtherTok{popQueue ::} \DataTypeTok{List}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Except} \DataTypeTok{Error}\NormalTok{ (a, }\DataTypeTok{List}\NormalTok{ a)}
\NormalTok{popQueue queue }\FunctionTok{=} 
    \KeywordTok{case}\NormalTok{ queue }\KeywordTok{of} 
\NormalTok{        [] }\OtherTok{->} 
\NormalTok{            Except.throwError }\DataTypeTok{QueueEmpty}

\NormalTok{        x }\FunctionTok{:}\NormalTok{ xs }\OtherTok{->} 
\NormalTok{            return ( x, xs )}
\end{Highlighting}
\end{Shaded}

Except and Either have a \texttt{Monad} instance. In this context
\texttt{return} means a non-error value, and
\texttt{\textgreater{}\textgreater{}=} allows us to chain multiple
operations that can fail, stopping when an error occurs.

\subsection{State and StateT}\label{state}

\texttt{State} is a wrapper around a function of type
\texttt{s\ -\textgreater{}\ (a,\ s)}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{State}\NormalTok{ s a }\FunctionTok{=} \DataTypeTok{State}\NormalTok{ \{}\OtherTok{ unState ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ (a, s) \} }
\end{Highlighting}
\end{Shaded}

It is used to give the illusion of mutable state, while remaining
completely pure. Intuitively, we can compose functions of this kind.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{f ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ (a,   s)}
\OtherTok{g ::}\NormalTok{       a }\OtherTok{->}\NormalTok{ s }\OtherTok{->}\NormalTok{ (b, s)}
\CommentTok{-- implies}
\OtherTok{h ::}\NormalTok{ s }\OtherTok{->}\NormalTok{            (b, s)}
\end{Highlighting}
\end{Shaded}

And this is exactly what monadic bind for state does.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{andThen ::} \DataTypeTok{State}\NormalTok{ s a }\OtherTok{->}\NormalTok{ (a }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s b) }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s b}
\NormalTok{andThen (}\DataTypeTok{State}\NormalTok{ first) tagger }\FunctionTok{=} 
    \DataTypeTok{State} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->} 
        \KeywordTok{let}\NormalTok{ (value, newState) }\FunctionTok{=}\NormalTok{ first s}
            \DataTypeTok{State}\NormalTok{ second }\FunctionTok{=}\NormalTok{ tagger value}
        \KeywordTok{in}
\NormalTok{            second newState }

\OtherTok{new ::}\NormalTok{ a }\OtherTok{->} \DataTypeTok{State}\NormalTok{ s a}
\NormalTok{new value }\FunctionTok{=} \DataTypeTok{State}\NormalTok{ (\textbackslash{}s }\OtherTok{->}\NormalTok{ (value, s))}

\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{State}\NormalTok{ s) }\KeywordTok{where}
\NormalTok{    (}\FunctionTok{>>=}\NormalTok{) }\FunctionTok{=}\NormalTok{ andThen}
\NormalTok{    return }\FunctionTok{=}\NormalTok{ new}
\end{Highlighting}
\end{Shaded}

When we want to combine monads, for instance to have both state and
error reporting, we must use monad transformers. The transformer is
needed because monads do not naturally combine: \texttt{m1\ (m2\ a)} may
not have a law-abiding monad instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{newtype} \DataTypeTok{StateT}\NormalTok{ s m a }\FunctionTok{=} \DataTypeTok{StateT}\NormalTok{ \{}\OtherTok{ runStateT ::}\NormalTok{ s }\OtherTok{->}\NormalTok{ m (a, s) \}  }

\KeywordTok{instance} \DataTypeTok{MonadTrans}\NormalTok{ (}\DataTypeTok{StateT}\NormalTok{ s) }\KeywordTok{where} 
\OtherTok{    lift ::}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ m) }\OtherTok{=>}\NormalTok{ m a }\OtherTok{->} \DataTypeTok{StateT}\NormalTok{ s m a}
\NormalTok{    lift m }\FunctionTok{=} \DataTypeTok{StateT} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->} \KeywordTok{do}
\NormalTok{        a }\OtherTok{<-}\NormalTok{ m}
\NormalTok{        return (a, s)}

\KeywordTok{instance}\NormalTok{ (}\DataTypeTok{Monad}\NormalTok{ m) }\OtherTok{=>} \DataTypeTok{Monad}\NormalTok{ (}\DataTypeTok{StateT}\NormalTok{ s m) }\KeywordTok{where}
\NormalTok{    return a }\FunctionTok{=} \DataTypeTok{StateT} \FunctionTok{$}\NormalTok{ \textbackslash{}s }\OtherTok{->}\NormalTok{ return (a, s)}
\end{Highlighting}
\end{Shaded}

The \texttt{MonadTrans} typeclass defines the \texttt{lift} function
that wraps a monadic value into the transformer. Next we define an
instance because we can say \emph{given a monad \texttt{m},
\texttt{StateT\ s\ m} is a law-abiding monad}.

\subsection{Factoring out recursion}\label{factoring-recursion}

A commonly used idiom in our code is to factor out recursion from a data
structure, using the \texttt{Fix} and \texttt{Monad.Free} types. Both
require the data type to be an instance of \texttt{Functor}: The type is
of the shape \texttt{f\ a} - like \texttt{List\ a} or \texttt{Maybe\ a},
and there exists a mapping function
\texttt{fmap\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ (f\ a\ -\textgreater{}\ f\ b)}.

Fix requires the data type to have a natural leaf: a constructor that
does not contain an \texttt{a}. \texttt{Free} on the other hand lets us
choose some other type for the leaves.

%\subsection{Fix}\label{fix}
%
%The \texttt{Fix} data type is the fixed point type.
%
%\begin{Shaded}
%\begin{Highlighting}[]
%\KeywordTok{data} \DataTypeTok{Fix}\NormalTok{ f }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (f (}\DataTypeTok{Fix}\NormalTok{ f))}
%\end{Highlighting}
%\end{Shaded}
%
%It allows us to express a type of the shape
%\texttt{f\ (f\ (f\ (f\ (..))))} concisely. For the values of this type
%to be finite, the \texttt{f} must have a constructor that does not
%recurse to be a leaf. Take for instance this simple expression language
%
%\begin{Shaded}
%\begin{Highlighting}[]
%\KeywordTok{data} \DataTypeTok{Expr}
%    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
%    \FunctionTok{|} \DataTypeTok{Add} \DataTypeTok{Expr} \DataTypeTok{Expr} 
%\end{Highlighting}
%\end{Shaded}
%
%\texttt{Literal} is the only constructor that can occur as a leaf, and
%\texttt{Add} is the only node. Using \texttt{Fix} we can equivalently
%write
%
%\begin{Shaded}
%\begin{Highlighting}[]
%\KeywordTok{data} \DataTypeTok{ExprF}\NormalTok{ next}
%    \FunctionTok{=} \DataTypeTok{Literal} \DataTypeTok{Int}
%    \FunctionTok{|} \DataTypeTok{Add}\NormalTok{ next next }
%\end{Highlighting}
%\end{Shaded}
%
%Defining values of type \texttt{Fix\ ExprF} requires wrapping of
%constructors with \texttt{Fix}. We will describe a better way of writing
%\texttt{Fix}ed values in Appendix~\ref{free-monad-dsl}.
%
%\begin{Shaded}
%\begin{Highlighting}[]
%\OtherTok{simple ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
%\NormalTok{simple }\FunctionTok{=} \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{42}\NormalTok{)}
%
%\OtherTok{complex ::} \DataTypeTok{Fix} \DataTypeTok{ExprF}
%\NormalTok{complex }\FunctionTok{=} 
%    \DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Add}\NormalTok{ (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{40}\NormalTok{)) (}\DataTypeTok{Fix}\NormalTok{ (}\DataTypeTok{Literal} \DecValTok{2}\NormalTok{)))}
%\end{Highlighting}
%\end{Shaded}
%
%By decoupling the recursion from the content, we can write functions
%that deal with only one level of the tree and apply them to the full
%tree. For instance evaluation of the above expression can be written as
%
%\begin{Shaded}
%\begin{Highlighting}[]
%\OtherTok{evaluate ::} \DataTypeTok{Fix} \DataTypeTok{ExprF} \OtherTok{->} \DataTypeTok{Int} 
%\NormalTok{evaluate }\FunctionTok{=} 
%\NormalTok{    Fix.cata }\FunctionTok{$}\NormalTok{ \textbackslash{}expr }\OtherTok{->} 
%        \KeywordTok{case}\NormalTok{ expr }\KeywordTok{of} 
%            \DataTypeTok{Literal}\NormalTok{ v }\OtherTok{->} 
%\NormalTok{                v}
%
%            \DataTypeTok{Add}\NormalTok{ a b }\OtherTok{->} 
%\NormalTok{                a }\FunctionTok{+}\NormalTok{ b}
%\end{Highlighting}
%\end{Shaded}
%
%The \texttt{cata} function - a catamorphism also known as a fold or
%reduce - applies evaluate from the bottom up. In the code we write, we
%only need to make local decisions and don't have to write the plumbing
%to get the recursion right.

\subsection{Monad.Free}\label{free-monad}

The Free monad is very similar to \texttt{Fix}, but allows us to use a
different type for the leaves, and enables us to use do-notation.
Writing expressions with \texttt{Fix} can be quite messy, free monads
allow us to write examples much more succinctly.

Free is defined as

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Free}\NormalTok{ f a}
    \FunctionTok{=} \DataTypeTok{Pure}\NormalTok{ a }
    \FunctionTok{|} \DataTypeTok{Free}\NormalTok{ (f (}\DataTypeTok{Free}\NormalTok{ f a))}
\end{Highlighting}
\end{Shaded}

and as the name suggests \texttt{Monad.Free} has a Monad instance.

This then makes it possible to define a functor that represents
instructions, define some helpers and then use do-notation to write our
actual programs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{StackF}\NormalTok{ a next }
    \FunctionTok{=} \DataTypeTok{Push}\NormalTok{ a next}
    \FunctionTok{|} \DataTypeTok{Pop}\NormalTok{ (a }\OtherTok{->}\NormalTok{ next)}
    \FunctionTok{|} \DataTypeTok{End} 
    \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Functor}\NormalTok{)}

\KeywordTok{type} \DataTypeTok{Stack}\NormalTok{ a }\FunctionTok{=} \DataTypeTok{Free} \DataTypeTok{StackF}\NormalTok{ a}
     
\OtherTok{program ::} \DataTypeTok{Stack} \DataTypeTok{Int}
\NormalTok{program }\FunctionTok{=} \KeywordTok{do} 
\NormalTok{    push }\DecValTok{5} 
\NormalTok{    push }\DecValTok{4} 
\NormalTok{    a }\OtherTok{<-}\NormalTok{ pop}
\NormalTok{    b }\OtherTok{<-}\NormalTok{ pop}
\NormalTok{    push (a }\FunctionTok{+}\NormalTok{ b)}

\OtherTok{push ::}\NormalTok{ a }\OtherTok{->} \DataTypeTok{Stack}\NormalTok{ a ()}
\NormalTok{push v }\FunctionTok{=}\NormalTok{ liftFree (}\DataTypeTok{Push}\NormalTok{ v ()) }

\OtherTok{pop ::} \DataTypeTok{Stack}\NormalTok{ a a }
\NormalTok{pop }\FunctionTok{=}\NormalTok{ liftFree (}\DataTypeTok{Pop}\NormalTok{ identity)}
\end{Highlighting}
\end{Shaded}

\subsection{Guaranteeing well-formedness of
Free}\label{well-formedness-free}

We use the free monad to build up programs and global types. A problem
with the free monad is that the built-up tree can still contain
``holes'' because of the \texttt{Pure\ \_} branch of \texttt{Free}. That
is fine while constructing the tree, but when evaluating it we want all
\texttt{Pure}s to be gone. There are two ways of enforcing this
constraint using the type systems.

We observe that only our leaves have a free type variable. For instance
for \texttt{HighLevelProgram}, only \texttt{terminate} (via NoOp) can
have type \texttt{HighLevelProgram\ a} where the \texttt{a} is unbound.
That means that \texttt{terminate} will unify with anything:
\texttt{HighLevelProgram\ String}, \texttt{HighLevelProgram\ Int}, etc.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{terminate ::} \DataTypeTok{HighLevelProgram}\NormalTok{ a}
\NormalTok{terminate }\FunctionTok{=} \DataTypeTok{HighLevelProgram}\NormalTok{ (liftF }\DataTypeTok{NoOp}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There are now two ways forward:

\begin{itemize}
\item \textbf{Solution 1: Rank2Types and Universal Quantification} \\
Now if we enforce that our whole program unifies with anything, that
implies that all \texttt{Pure}s are gone from the structure. Normally,
type signatures are valid if there is at least one valid unification for
every type variable (i.e.~existential quantification). But with the
language extension \texttt{ExplicitForAll} we can mark type variables as
universally quantified: they need to unify with all types. In this case
we also need \texttt{Rank2Types} because of the position where we want
to use \texttt{forall}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{\{-# LANGUAGE Rank2Types #-\}}
\OtherTok{\{-# LANGUAGE ExplicitForAll #-\}}

\OtherTok{compile ::} \DataTypeTok{Participant} \OtherTok{->}\NormalTok{ (forall a}\FunctionTok{.} \DataTypeTok{HighLevelProgram}\NormalTok{ a) }\OtherTok{->} \DataTypeTok{Program} \DataTypeTok{Value}
\NormalTok{compile participant (}\DataTypeTok{HighLevelProgram}\NormalTok{ program) }\FunctionTok{=} \FunctionTok{...}
\end{Highlighting}
\end{Shaded}

\item \textbf{Solution 2: Data.Void} \\
The second solution is to use \texttt{Data.Void}. \texttt{Void} is the
data type with zero values, which means there is no valid way of
creating a value of type \texttt{Void}. Thus a \texttt{Free\ f\ Void}
cannot have any \texttt{Pure}s, because they need a value of type
\texttt{Void} and there are none.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{import }\DataTypeTok{Data.Void}\NormalTok{ (}\DataTypeTok{Void}\NormalTok{)}

\OtherTok{compile ::} \DataTypeTok{Participant} \OtherTok{->} \DataTypeTok{HighLevelProgram} \DataTypeTok{Void} \OtherTok{->} \DataTypeTok{Program} \DataTypeTok{Value}
\NormalTok{compile participant (}\DataTypeTok{HighLevelProgram}\NormalTok{ program) }\FunctionTok{=} \FunctionTok{...}
\end{Highlighting}
\end{Shaded}

\item \textbf{Tradeoffs} \\
In the codebase we went with solution 2 because it produces clearer
error messages and does not introduce extra language extensions to the
project.
\end{itemize}

\subsection{Scheduling code}\label{scheduling-code}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Progress} \FunctionTok{=} \DataTypeTok{Progress} \FunctionTok{|} \DataTypeTok{NoProgress} \KeywordTok{deriving}\NormalTok{ (}\DataTypeTok{Eq}\NormalTok{, }\DataTypeTok{Show}\NormalTok{)}

\NormalTok{round}\OtherTok{ ::} \DataTypeTok{List} \DataTypeTok{Location} \OtherTok{->} \DataTypeTok{ExecutionState} \DataTypeTok{Value} 
      \OtherTok{->} \DataTypeTok{Either} \DataTypeTok{Error}\NormalTok{ ( }\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{)}
\NormalTok{                      , }\DataTypeTok{ExecutionState} \DataTypeTok{Value}
\NormalTok{                      )}
\NormalTok{round locations state }\FunctionTok{=} 
\NormalTok{    foldM helper [] locations }
        \FunctionTok{|>}\NormalTok{ flip State.runStateT state}
        \FunctionTok{|>}\NormalTok{ Except.runExcept}
  \KeywordTok{where}\OtherTok{ helper ::} \DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{) }\OtherTok{->} \DataTypeTok{Location} 
               \OtherTok{->} \DataTypeTok{Session} \DataTypeTok{Value}\NormalTok{ (}\DataTypeTok{List}\NormalTok{ (}\DataTypeTok{Location}\NormalTok{, }\DataTypeTok{Progress}\NormalTok{))}
\NormalTok{        helper accum location }\FunctionTok{=} \KeywordTok{do}
\NormalTok{            state }\OtherTok{<-}\NormalTok{ State.get}

            \KeywordTok{let}\NormalTok{ evaluated }\FunctionTok{=} 
\NormalTok{                    State.runStateT (forward location) state }
                        \FunctionTok{|>}\NormalTok{ Except.runExcept }

            \KeywordTok{case}\NormalTok{ evaluated }\KeywordTok{of}
                \DataTypeTok{Right}\NormalTok{ ( _, s ) }\OtherTok{->} \KeywordTok{do}
\NormalTok{                    State.put s}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{Progress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{QueueError}\NormalTok{ origin (}\DataTypeTok{InvalidQueueItem}\NormalTok{ message)) }\OtherTok{->} 
                    \CommentTok{-- blocked on receive, try moving others forward}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{NoProgress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{QueueError}\NormalTok{ origin }\DataTypeTok{EmptyQueue}\NormalTok{) }\OtherTok{->} 
                    \CommentTok{-- blocked on receive, try moving others forward}
\NormalTok{                    return }\FunctionTok{$}\NormalTok{ ( location, }\DataTypeTok{NoProgress}\NormalTok{ ) }\FunctionTok{:}\NormalTok{ accum }

                \DataTypeTok{Left} \DataTypeTok{Terminated} \OtherTok{->} 
\NormalTok{                    return accum}
                            
                \DataTypeTok{Left}\NormalTok{ err }\OtherTok{->} 
                    \CommentTok{-- other errors are raised}
\NormalTok{                    Except.throwError err}


\OtherTok{untilError ::} \DataTypeTok{ExecutionState} \DataTypeTok{Value} 
           \OtherTok{->} \DataTypeTok{Either} \DataTypeTok{Error}\NormalTok{ (}\DataTypeTok{ExecutionState} \DataTypeTok{Value}\NormalTok{)}
\NormalTok{untilError state}\FunctionTok{@}\DataTypeTok{ExecutionState}\NormalTok{\{ locations \} }\FunctionTok{=} 
\NormalTok{    helper (Map.keys locations) state}
  \KeywordTok{where}\NormalTok{ helper locations state }\FunctionTok{=} \KeywordTok{do}
\NormalTok{            ( locationProgress, newState ) }\OtherTok{<-} 
\NormalTok{                Interpreter.round locations state}

            \KeywordTok{let}\NormalTok{ isProgress }\FunctionTok{=}  
\NormalTok{                    any }
\NormalTok{                        (\textbackslash{}(_, progress) }\OtherTok{->}\NormalTok{ progress }\FunctionTok{==} \DataTypeTok{Progress}\NormalTok{) }
\NormalTok{                        locationProgress }

            \KeywordTok{if}\NormalTok{ null locationProgress }\KeywordTok{then} 
                \CommentTok{-- no active locations}
                \DataTypeTok{Right}\NormalTok{ state}

            \KeywordTok{else} \KeywordTok{if}\NormalTok{ isProgress }\KeywordTok{then} 
\NormalTok{                helper (List.map fst locationProgress) newState}

            \KeywordTok{else}
\NormalTok{                error }\FunctionTok{$} \StringTok{"DEADLOCK\textbackslash{}n"} \FunctionTok{++}\NormalTok{ show state}
\end{Highlighting}
\end{Shaded}

\end{document}


