% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx,hyperref}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}
\usepackage{xcolor,xspace,amsmath,amsfonts,stmaryrd,amssymb,enumerate,times}
\usepackage{mathpartir}

\newcommand{\todo}[1]{\textcolor{red}{TO DO:#1}}
\newcommand{\erase}[1]{#1}

\input{macrosCR}

\begin{document}

%
\title{Reversible Session-Based Concurrency \\ in Haskell (Draft of a Full Research Paper)\thanks{This work was partially supported by the EU COST action IC1405 (Reversible Computation -- Extending Horizons of Computing).}}
%
\titlerunning{Reversible Session-Based Concurrency in Haskell}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Folkert de Vries\thanks{Main author - BSc student.} \and
Jorge A. P\'{e}rez%\orcidID{0000-0002-1452-6180}}
}
%
\authorrunning{F.\ de Vries and J.\ A.\ P\'{e}rez}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Groningen, The Netherlands}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Under a reversible semantics, computation steps can be undone. 
For message-passing, concurrent programs, reversing computation steps is a challenging and delicate task; one typically aims at a formal semantics which is \emph{causal\-ly-consistent}. 
Prior work has addressed this challenge in the context of a process model of multiparty protocols (choreographies) following a so-called \emph{monitors-as-memories} approach.
In this paper, we describe our ongoing work on implementing this specific reversible operational semantics in Haskell. 
\keywords{Reversible computation \and Message-passing concurrency  \and Haskell.}
\end{abstract}
%
%
%
\section{Introduction}
This paper describes ongoing work aimed at developing a Haskell implementation of 
\emph{reversible, message-passing concurrency}. 
Our implementation is framed within a rather prolific line of research, which aims at  
establishing rigorous semantic foundations for reversible computing in the challenging 
concurrent setting (see, e.g., the survey~\cite{DBLP:journals/eatcs/Lanese14}).
Our key interest is the interplay of reversibility and message-passing concurrency, which is typically governed by
\emph{protocols} among possibly distributed partners.

In a programming language with a reversible semantics, computation steps can be undone.
Reversing a sequential program is not hard: we should record enough information about standard forward steps in case we wish to return to a prior state. Reversing a concurrent program is  more difficult: since in a concurrent program control resides in more than one point, we require carefully designed \emph{memories} that not only record information about prior actions, but also about the \emph{causal dependencies} between actions originated in different threads.
For this reason, in a reversible, concurrent setting it is highly desirable to have a semantics which is \emph{causally consistent}. Causal consistency ensures that reversible steps lead to system states that could been have reached by performing forward steps only. That is, causally consistent reversibility does not lead to extraneous states, not reachable through ordinary forward computations.

The quest for causally consistent reversible semantics for (message-passing) concurrency has led to a number of valuable proposals (cf.~\cite{DBLP:conf/ppdp/MezzinaP17} and references therein). One common drawback in several of those works is that the memories used are rather heavy, and so the resulting reversible semantics are overly complex. This is a particularly notorious drawback in the work of Mezzina and P\'{e}rez in~\cite{DBLP:conf/ppdp/MezzinaP17}, which addresses reversibility in the context of concurrent processes whose communication actions are governed by \emph{choreographies} defined by \emph{multiparty session types}~\cite{HYC08}. The reversible semantics developed in~\cite{DBLP:conf/ppdp/MezzinaP17} is causally consistent; however, it is far from clear whether it can be implemented as  actual tools for the  analysis of message-passing, concurrent programs.

In this paper, we describe a Haskell implementation of the reversible semantics proposed in~\cite{DBLP:conf/ppdp/MezzinaP17}. More precisely, we present a Haskell interpreter of message-passing programs written in the reversible process framework in~\cite{DBLP:conf/ppdp/MezzinaP17}. This allows us to assess in practice the benefits and features of the memories and mechanisms deployed in~\cite{DBLP:conf/ppdp/MezzinaP17} to enforce causally consistent reversibility. In this process, we have found the use of a functional programming language---and in particular, of Haskell---a natural choice. PLEASE BRIEFLY ELABORATE ON BENEFITS OF USING HASKELL.

\section{The Process Model}
% !TEX root = rev_chor_journal.tex

This section summarizes the reversible process model proposed by Mezzina and P\'{e}rez in~\cite{DBLP:conf/ppdp/MezzinaP17}, which provides the formal basis for the Haskell implementation that we present in the following section (the main contribution of the present paper).

\begin{figure}[!t]
\begin{center}
    \includegraphics[width=8.7cm]{./img/figmodel.pdf}
\end{center}
\vspace{-4mm}
\caption{The process model of multiparty communications defined in~\cite{DBLP:conf/ppdp/MezzinaP17}.}\label{f:model}
\vspace{-4mm}
\end{figure}
Fig.~\ref{f:model} depicts the ingredients of our
two-level model of \emph{choreographies} and \emph{configurations/processes}.
Choreographies are defined in terms of \emph{global types}, which describe a protocol among two or more participants. 
A global type can be \emph{projected} onto each participant so as to obtain 
a \emph{local type}, i.e., a session type that abstracts a participant's contribution to the global protocol. 
(We often use `choreographies' and `global types' as synonyms.)
The semantics of global types is given in terms of forward and backward  transition systems (Fig.~\ref{f:gts}). 
There is a \emph{configuration} for each protocol participant: it includes a \emph{located process}
that 
 specifies asynchronous communication behavior, subject to a \emph{monitor}
that enables forward/backward steps at run-time
based on the local type.
The semantics of configurations is given in terms of forward and backward reduction relations (Figs.~\ref{fig:fw} and~\ref{fig:bk}).
Below, we  use colors to improve readability:
elements in \fwcolor{blue} belong to a forward semantics;
elements in \bkcolor{red} belong to a backward semantics.
%Given this two-level setting, our goal will be that of connecting (i)~forward and backward steps at the (high) level of choreographic specifications, and (ii) forward and backward steps at the (low) level of configurations/processes. This will be content of 
%Theorem~\ref{t:corrgc}.

\subsection{Global and Local Types}

\subsubsection{Syntax}
Let us write $\p, \q, \gpart{r}, \pA, \pB \ldots$ to denote (protocol) \emph{participants}.
The syntax of global types ($G, G', \ldots$) and local types  ($T, T', \ldots$) follows standard lines~\cite{HYC08}:
\begin{align*}
			G, G'  \bnfis & \gtcom{p}{q}{U}{G} %\bnfbar 
			\sbnfbar
			\gtcho{p}{q}{\lbl_i}{G_i} %\\
			\sbnfbar %& 
			\mu X. G \sbnfbar X \sbnfbar \gend \\
			U, U'  \bnfis & \bool \sbnfbar \nat \sbnfbar \cdots %\bnfbar T 
			\sbnfbar \shot{T} \\
	    	T, T'  \bnfis & \ltout{p}{U}{T} \sbnfbar \ltinp{p}{U}{T} %\\
		  \sbnfbar %& 
		  \ltsel{p}{\lbl_i}{T_i}{i}{I} \sbnfbar \ltbra{p}{\lbl_i}{T_i}{i}{I}  
		 %\lsend{p}{\lbl_i}{U_i}{T_i} \bnfbar \lrecv{q}{\lbl_i}{U_i}{T_i} \bnfbar 
		\sbnfbar  \mu X. T \sbnfbar X \sbnfbar \lend 
\end{align*}
\noindent
Global type $\gtcom{p}{q}{U}{G}$ says that \p may send a value of type $U$ to \q, and then continue as $G$.
Given a finite index set $I$ and pairwise different \emph{labels} $\lbl_i$, global type $\gtcho{p}{q}{\lbl_i}{G_i}$ says that  \p may choose  label $\lbl_i$, communicate this selection to \q, and then continue as $G_i$.
In these two types %thus denote direct communications; 
we assume that $\p \neq \q$.
%We also considered labeled choices in global types.
%For the sake of presentation, here we do not consider labeled choices in global types; these can be easily accommodated---see \S\,\ref{s:ext} and~\cite{MezzinaP17arxiv}.
Global %types include also 
recursive and terminated protocols are denoted $\mu X. G$ and $\gend$, respectively.
The set $\parties{G}$ contains the participants in $G$.
Value types $U$ include basic first-order values (constants),   but also \emph{higher-order} values: abstractions from names to processes. 
(We write $\Proc$ to denote the type of processes.)
Local types 
%abstract the behavior of individual participants. Types 
$\ltout{p}{U}{T}$ and $\ltinp{p}{U}{T}$ denote, respectively, an output and input of value of type $U$ by \p.
\added{We use  $\alpha$ to denote type prefixes  $\typeIn{\p}{U}$, $\typeOut{\p}{U}$.}
Type $\ltbra{p}{\lbl_i}{T_i}{i}{I}$ says that \p 
offers different behaviors, available as labeled alternatives;
conversely, type $\ltsel{\p}{\lbl_i}{T_i}{i}{I}$ 
says that \p may select one of such alternatives.
 Terminated and recursive local types are denoted $\lend$ and $\mu X. T$, respectively. 

As usual, we consider only recursive types $\mu X. G$ (and $\mu X. T$) in which $X$ occurs guarded in $G$ (and $T$).
 We shall take an equi-recursive view of (global and local) types: we consider two  types with the same regular tree as equal.
 
Global and local types are related by  \emph{projection} (Fig.~\ref{f:proj}):
the projection of global type $G$ onto participant $\gpart{r}$ is written $\tproj{G}{\gpart{r}}$. 
\modif{Intuitively, $\tproj{G}{\gpart{r}}$ denotes the (local) contribution of   $\gpart{r}$ to the overall choreographic behavior that $G$ declaratively specifies.}
%As such, the projection of a directed communication $\gtcom{p}{q}{U}{G'}$ onto $\gpart{r}$ depends on
%$\gpart{r}$'s involvement, which is reflected locally as an input or output local type (if $\gpart{r}$ is indeed involved) or 
%as the terminated local protocol (otherwise). The projection of 
%recursive choreographies follows a similar principle; recursive variables and the terminated choreography are projected as expected.}
%%\modif{The projection  $\tproj{G}{\p}$ extrapolates the overall (local) behaviour of participant $\p$ from the global type G: if $p$ is involved into a communication from a global point of view then this is also reflected into its local type. Recursive type definitions, recursive variables and terminated  protocol are translated into the corresponding local ones.} 
%\added{Projection for $\gtcho{p}{q}{l_i}{G_i}$ is noteworthy: 
%the projections of the participants not involved in the choice (different from $\p, \q$) should correspond to the same identical local type.}
\begin{figure}[t!]
{%\small
\begin{align*}
\tproj{(\gtcom{p}{q}{U}{G})}{\gpart{r}} & = 
\begin{cases}
\ltout{\q}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{p}$} \\
\ltinp{\p}{U}{(\tproj{G}{\gpart{r}})} & \text{if $\gpart{r} = \gpart{q}$} \\
(\tproj{G}{\gpart{r}}) &  \text{if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$}
\end{cases}
\\
\tproj{(\gtcho{p}{q}{l_i}{G_i})}{\gpart{r}}  
& 
\erase{= 
\begin{cases}
\ltsel{\q}{\lbl_i}{(\tproj{G_i}{\gpart{r}})}{i}{I}  & \text{ if $\gpart{r} = \gpart{p}$} \\
\ltbra{\p}{\lbl_i}{\tproj{G_i}{\gpart{r}}}{i}{I}  & \text{ if $\gpart{r} = \gpart{q}$} \\
(\tproj{{G_1}}{\gpart{r}}) &  \text{ if $\gpart{r} \neq \gpart{q}, \gpart{r} \neq \gpart{p}$ and} \\ 
& \text{~~$\forall i, j \in I. \tproj{{G_i}}{\gpart{r}} = \tproj{{G_j}}{\gpart{r}}$}
\end{cases}
}
\\
\tproj{(\mu X. G)}{\gpart{r}} &= 
\begin{cases}
\mu X. \tproj{G}{\gpart{r}} & \text{if $\gpart{r}$ occurs in $G$}
\\
\lend & \text{otherwise}
\end{cases}
\\
\tproj{X}{\gpart{r}} & = X
\qquad
\tproj{\gend}{\gpart{r}} = \lend
\end{align*}
}
\vspace{-4mm}
\caption{Projection of a global type $G$ onto a participant $\gpart{r}$.\label{f:proj}}
\end{figure}

\subsubsection{Semantics of Choreographies}\label{ss:chore}
\begin{figure}[t!]
{%\small
\begin{mathpar}
\inferrule*[left=\fwcolor{(FVal1)}]{}
{\ctx{G}[ \past \gtcom{p}{q}{U}{G}] 
\fwg 
\ctx{G}[\gtcom{p}{\!\!\past q}{U}{G} ]}
\\
\inferrule*[left=\fwcolor{(FVal2)}]{}
{\ctx{G}[  \gtcom{p}{\!\!\past q}{U}{G}] 
\fwg 
\ctx{G}[\gtcom{p}{q}{U}{\past G} ]}
%\\
\\
\inferrule*[left=\fwcolor{(FCho1)}]{}
{
%\begin{array}{c}
\ctx{G}[\past \gtcho{p}{q}{l_i}{G_i}] 
\fwg  
\ctx{G}[\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} ] 
%\end{array}
}
\\
%\\
\inferrule*[left=\fwcolor{(FCho2)}]{}
{
%\begin{array}{c}
\ctx{G}[\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} ] 
\fwg
\ctx{G}[\gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:\past G_j\}_{i \in I\setminus j} ] 
%\end{array}
}
%
\\
%%
\inferrule*[left=\bkcolor{(BVal1)}]{}
{\ctx{G}[\gtcom{p}{\!\!\past q}{U}{G} ]
\bkg
\ctx{G}[ \past \gtcom{p}{q}{U}{G}] 
}
\\
\inferrule*[left=\bkcolor{(BVal2)}]{}
{
\ctx{G}[\gtcom{p}{q}{U}{\past G} ]
\bkg
\ctx{G}[  \gtcom{p}{\!\!\past q}{U}{G}] 
}
\\
\inferrule*[left=\bkcolor{(BCho1)}]{}
{
%\begin{array}{c}
\ctx{G}[\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} ] 
%\qquad \qquad
%\\
%\qquad \qquad
\bkg  
\ctx{G}[\past \gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} ]
%\end{array}
}
\\
\inferrule*[left=\bkcolor{(BCho2)}]{}
{
%\begin{array}{c}
\ctx{G}[\gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:\past G_j\}_{i \in I\setminus j} ]
%\qquad \qquad
%\\
%\qquad \qquad
\bkg 
\ctx{G}[\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} ] 
%\end{array}
}

\end{mathpar}
}
\vspace{-4mm}
\caption{Semantics of Global Types (Forward \& Backwards).\label{f:gts}}
\label{fig:prot_sem}
\end{figure}

The semantics of global types (Fig.~\ref{fig:prot_sem})
comprises forward and backward transition rules. 
%\jp{Indeed, our semantics seems more like an ``unlabeled LTS''. Could it be that labels will be useful later on?}
To express backward steps, we require some auxiliary notions.
\emph{Global contexts}, ranged over by $\ctx{G}, \ctx{G}', \ldots$ with holes $\bullet$,  record
previous actions, including the choices discarded and committed:
%\begin{center}
$$
\ctx{G}
\bnfis   
\bullet 
\sbnfbar  
\ctx{G}[\gtcom{p}{q}{U}{\ctx G}]
\sbnfbar
\ctx{G}[\gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:\ctx{G}\}_{i \in I\setminus j} ]
$$
%\end{center}
We also use \emph{global types with history}, ranged over by $\mathsf{H}, \mathsf{H}', \ldots$, 
  to record the current protocol state. 
This state is denoted by the \emph{cursor}~$\past$:
\begin{align*}
			\mathsf{H}, \mathsf{H}'  \bnfis & 			\past G \sbnfbar	G \past 
			\sbnfbar 
			\gtcom{p}{\!\!\past q}{U}{G} 
			\sbnfbar 
			\gtcom{p}{q}{U}{\past G} 
			\\\sbnfbar & 
			\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j} 
			%\\ \sbnfbar & 
			\sbnfbar
 			\gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:\past G_j\}_{i \in I\setminus j}  
\end{align*}
%Projection and notation $\parties{\cdot}$ extend easily to global types $\gth{H}$ (cf. Fig.~\ref{f:projext}).
%Notation $\parties{\cdot}$ extends easily to global types $\gth{H}$.
Intuitively,  directed exchanges such as $\gtcom{p}{q}{U}{G}$ have three \emph{intermediate states},
characterized by the decoupled involvement of \p and \q in the intended asynchronous model.
The \emph{first state}, denoted $\past \gtcom{p}{q}{U}{G}$, describes the situation prior to the exchange.
The \emph{second state} represents the point in which \p has sent a value of type $U$ but this message has not yet
reached \q; this is denoted $\gtcom{p}{\!\!\past q}{U}{G}$.
The \emph{third state} represents the point in which \q has received the message from \p and
the continuation $G$ is ready to execute; this is denoted by $\gtcom{p}{q}{U}{\past G}$.
%\modif{Using these intermediate states is central to precisely characterize the intended asynchronous semantics for processes.}
These intuitions extend to $\gtcho{p}{q}{l_i}{G_i}$, with the following caveat:
the second state should distinguish the choice made by $\p$ from the discarded alternatives; 
  we write $\gpart{p}\to\!\!\past\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:G_j\}_{i \in I\setminus j}$ to describe that $\p$ has selected $\lbl_j$ and that this choice is still to be received by \q. Once this occurs, a state
  $\gpart{p}\to\gpart{q}:\{\lbl_i:G_i \,;\, \lbl_j:\past G_j\}_{i \in I\setminus j}$ is reached.

These  intuitions come in handy to describe the forward and backward transition rules
in Fig.~\ref{fig:prot_sem}. 
For a forward directed exchange of a value, 
Rule~\fwcolor{\textsc{(FVal1)}} formalizes the transition from the first   to the second state;
Rule~\fwcolor{\textsc{(FVal2)}} denotes the transition from the second to the third state.
Rules~\fwcolor{\textsc{(FCho1)}} and~\fwcolor{\textsc{(FCho2)}} are their analogues for the forward directed communication of a label.
Rules \bkcolor{\textsc{(BVal1)}} and \bkcolor{\textsc{(BVal2)}} undo the step performed by 
Rules~\fwcolor{\textsc{(FVal1)}} and~\fwcolor{\textsc{(FVal2)}}, respectively. 
\erase{Also, 
Rules~\bkcolor{\textsc{(BCho1)}} and~\bkcolor{\textsc{(BCho2)}} undo the step performed by 
Rules~\fwcolor{\textsc{(FCho1)}} and~\fwcolor{\textsc{(FCho2)}}, respectively.} 




\subsection{Processes and Configurations}
\label{subsec:syntax}

	\begin{figure}[t!]
	%{\small
		\begin{align*}
			u,w  \bnfis& n \sbnfbar x,y,z
			\qquad \quad
			n,n' \bnfis a,b \sbnfbar \ep{s}{\p}%, \dual{s} 
			\\
			 {v},  {v}'  \bnfis &  \true \sbnfbar \false \sbnfbar \cdots
			\\
			V,W \bnfis & {a,b} \sbnfbar  x,y,z \sbnfbar  v, v' \sbnfbar {\abs{x}{P}}
			\\%[1mm]
			P,Q
			 \bnfis &
			\bout{u}{V}{P}  \sbnfbar  \binp{u}{x}{P} 
			\erase{\sbnfbar \bsel{u}{\lbl_i. P_i}_{i\in I} \sbnfbar \bbra{u}{\lbl_i:P_i}_{i \in I}  }
			 \\
			 & 
			 \sbnfbar  P \Par Q \sbnfbar  {\rvar{X} \sbnfbar \recp{X}{P}} 
						\sbnfbar  
			 {\appl{V}{u}}  
			\sbnfbar \news{n} P \sbnfbar \inact
\\
M,N		 \bnfis &
\myloc{\loc}{\bout{a}{x}{P}}
\sbnfbar 
\myloc{\loc}{\binp{a}{x}{P}}
\sbnfbar 
M \Par N 
\sbnfbar 
\news{n} M
\sbnfbar 
\inact 
\\
& \sbnfbar 
\rtsyn{\np{\ep{\loc}{\p}}{\conf{\stack C}{P}}} %% running process
\sbnfbar 
\rtsyn{\monig{\ep{s}{\p}}{H}{\mytilde{x}}{\store}}  %% monitor
\sbnfbar 
\rtsyn{\codah{s}{h_i}{h_o}%{\restrict{\mytilde{\gpart{r}}}}
} % queue
\sbnfbar 
\rtsyn{\mem{k}{(\appl{V}{u})}{\loc}} % function
	\\
	\erase{\stack{C}, \stack{C}' \bnfis}  & \erase{\inact \sbnfbar \bsel{u}{\lbl_i. P_i}_{i\in I} \sbnfbar 
\bbra{u}{ \lbl_i:P_i}_{i \in I} \sbnfbar \stack{C}_1, \stack{C}_2}
\\
	\mytagg \bnfis & \rmark \sbnfbar \normark
\qquad
	 h \bnfis  \emp   \sbnfbar h \cons \valueq{\p}{\q}{m} \qquad m \bnfis V \erase{\sbnfbar \lbl}
\\[2mm]
%
    \alpha \bnfis &   \typeIn{\q}{U} \sbnfbar  \typeOut{\q}{U} 
    \\
	T,S		 \bnfis & \lend \sbnfbar	\alpha.S \erase{\sbnfbar \ltsel{\q}{\lbl_i}{S_i}{i}{I} \sbnfbar \ltbra{\q}{\lbl_i}{S_i}{i}{I}}
	\\
	H,K		 \bnfis & \past S \sbnfbar S\past \sbnfbar \alpha_1.\cdots .\alpha_n.\past S 
%	\\
%	& 
	\erase{\sbnfbar  
	\ltselp{\q}{\lbl_i:S_i \;;\; \lbl_j:H_j}{i}{I} \sbnfbar \ltbrap{\q}{\lbl_i:S_i \, , \, \lbl_j:H_j}{i}{I}}
		\end{align*}
		\vspace{-4mm}
	\caption{\newjb{Syntax of processes $P, Q$, configurations $M, N$, 
	  \erase{stacks $\stack{C}, \stack{C}'$, }
	local types $T, S$, local types with history $H, K$.
    Constructs given in \rtsyn{\text{boxes}} appear only at run-time.}}
	\label{fig:syntax}
	\vspace{-1mm}
\end{figure}


\subsubsection{Syntax}
The syntax of processes and configurations is given in \figref{fig:syntax}.
%For processes $P, Q, \ldots$ we follow closely the syntax of \HOp, the core higher-order session $\pi$-calculus~\cite{KPY2016}.
%(In turn, \HOp is a subcalculus of the higher-order language studied  in~\cite{tlca07}.) 
The syntax of configurations builds upon that of processes.
%Next, we describe all these syntactic elements.

%\myparagraph{Values}
\emph{Names} $a,b,c$ (resp.~$s, s'$) 
range over shared (resp. session) names. 
We use session names indexed by  {participants}, denoted $\ep{s}{\p}, \ep{s}{\q}$. 
Names $n, m$ are session or shared names.
\added{First-order values  $v, v'$ include base values and constants.}
%Dual endpoints are $\dual{n}$ with $\dual{\dual{s}} = s$ and $\dual{a} = a$.
%We define the dual operation over names $n$ as $\dual{n}$ with
%$\dual{\dual{s}} = s$ and $\dual{a} = a$.
%Intuitively, names $s$ and $\dual{s}$ are dual (two) \emph{endpoints} while 
%shared names represent shared (non-deterministic) points. 
Variables are denoted by $x, y$, 
and recursive variables are denoted by $\varp{X}, \varp{Y}$.
The syntax of values $V$ includes shared names, first-order values, but also 
name abstractions (higher-order values)
$\abs{x}{P}$,   where $P$ is a process.
\added{As shown in~\cite{KPY2016}, abstraction passing suffices to express name passing (\emph{delegation}).}

Process terms include   prefixes for sending and receiving values $V$, written 
$\bout{u}{V} P$ and $\binp{u}{x} P$, respectively.
\erase{\added{Given a finite index set $I$,}
processes $\bsel{u}{\lbl_i. P_i}_{i\in I}$ and $\bbra{u}{l_i: P_i}_{i \in I}$ implement 
selection and branching (internal and external labeled choices, respectively). 
The selection  $\bsel{u}{\lbl_i. P_i}_{i\in I}$ is actually 
a non-deterministic choice over $I$.}
%In an improvement with respect to~\cite{DBLP:journals/corr/MezzinaP16,MezzinaP17}, h
Here we consider parallel composition of processes $P \Par Q$ 
and recursion $\recp{X}{P}$ (which binds the recursive variable $\varp{X}$ in process $P$).
%as we will discuss, adding these constructs entails challenges in the characterization of 
%causal consistent semantics (see next section).
Process 
$\appl{V}{u}$ 
is the application
which substitutes name $u$ on the abstraction~$V$. %; our semantics will ensure that $V$ is not a name.
Constructs for 
name restriction $\news{n} P$ and 
inaction $\inact$ are standard.
Session restriction $\news{s} P$ simultaneously binds all the participant endpoints in $P$.
We write $\fv{P}$ and $\fn{P}$ %, and $\sn{P}$ 
to denote the sets of free 
variables 
and names in $P$.
We assume $V$ in $\bout{u}{V}{P}$ does not include free recursive 
variables $\rvar{X}$.
If $\fv{P} = \emptyset$, we call $P$ {\em closed}.


%\\
Building upon processes, the syntax of configurations $M, N, \ldots$ includes constructs for \emph{session initiation}: 
\begin{enumerate}[$\bullet$]
\item configuration $\myloc{\loc}{\bout{a}{x}{P}}$ denotes the \emph{request} of a service identified with $a$ implemented in 
$P$ as $x$; 
\item conversely, configuration 
$\myloc{\loc}{\binp{a}{x}{P}}$
denotes service \emph{acceptance}. 
\end{enumerate}
In these constructs,  identifiers $\loc, \loc', \ldots$ denote    a  \emph{location} 
or  \emph{site}. % (as in, e.g., the distributed $\pi$-calculus~\cite{Hennessy07}).
Locations indexed by participants, useful in run-time expressions, are denoted $\ep{\loc}{\p}, \ep{\loc}{\q}$.
Configurations also include
inaction $\inact$, parallel composition  $M \Par N$,
name restriction $\news{n} M$, as well as
 the following \emph{run-time elements}: %, not part of ``source'' processes:
 
\begin{enumerate}[$\bullet$]
\item \emph{Running processes} are of the form $\np{\ep{\loc}{\p}}{\conf{\stack C}{P}}$, where $\loc$ is a location that 
hosts a process $P$ \erase{ and a \emph{(process) stack} $\stack{C}$} that implements participant $\p$.
\erase{A process stack is a list of processes, useful 
  to record/reinstate the discarded alternatives   in a choice.}

\item \emph{Monitors} are of the form $\monig{\ep{s}{\p}}{H}{\mytilde{x}}{\store}$ 
where 
$s$ is the session being monitored, 
$\p$ is a participant,
$H$ is a history session type, 
$\mytilde{x}$ is a set of free variables, 
and the \emph{store} $\store$  records the value of such variables (see Def.~\ref{d:store}).
These elements allow us to track the current protocol
and  state of the   monitored process.

Also, each monitor has a 
\emph{tag} $\mytagg$, which can be either \emph{empty} (denoted `$\normark$') or \emph{full} (denoted `$\rmark$'). 
When created all monitors have an empty tag; a full tag indicates that the running process associated to the monitor
is currently involved in a  decoupled reversible step.
\added{We often omit the empty tag 
(so we write 
$\moni{\ep{s}{\p}}{H}{\mytilde{x}}{\store}$ instead of 
$\hmoni{\ep{s}{\p}}{H}{\mytilde{x}}{\store}$)
and write $\monir{\ep{s}{\p}}{H}{\mytilde{x}}{\store}$ to emphasize the reversible (red) nature of a 
monitor with full tag.}


\item Following~\cite{DBLP:journals/mscs/KouzapasYHH16}, we have \emph{message queues}
of the form 
%$\codah{s}{h_i}{h_o}{\restrict{\mytilde{\p}}}$,
$\codah{s}{h_i}{h_o}$,
where $s$ is a session, $h_i$ is the input part of the queue, and $h_o$ is the output part of the queue.
Each queue contains messages of the form $\valueq{\p}{\q}{\anyv}$ (read: ``message $\anyv$ is sent from $\p$ to $\q$'').
The effect of an output prefix in a process is to place the message in its corresponding output queue;
conversely, the effect of an input prefix is to obtain the first message from its input queue. 
\added{Messages in the queue are \textit{never consumed}: a process reads a message $\valueq{\p}{\q}{\anyv}$ by moving it from the (tail of) queue $h_o$ to the (top of) queue $h_i$. This way, the    delimiter `$\history$' distinguishes the \textit{past} of the queue from its \textit{future}.}

%Also, $\mytilde{\p}$ denotes a sequence of participant identities currently involved in a reversible step; when this sequence is empty, we  write  $\codah{s}{h_i}{h_o}{~}$ instead of $\codah{s}{h_i}{h_o}{\restrict{\epsilon}}$.

\item We use \emph{running functions} of the form $\mem{k}{(\appl{V}{u})}{\loc}$ to reverse
 applications $\appl{V}{u}$. While $k$ is a fresh identifier (key) for this term, $\loc$ is the location of 
the running process that contains the application.

\end{enumerate}

\noindent
We shall write $\procs$ and $\confs$ to indicate the set of processes and configurations, respectively. 
We call \emph{agent} an element of the set $\agents = \confs \cup \procs$. 
We let $P, Q$  to range over $\procs$; also, we use $L,M,N$ to range over $\confs$ and $A,B,C$ to range over $\agents$.
%; and closed $P$ without 
%free session names a {\em program}. 





\subsubsection{A Decoupled Semantics for Configurations}\label{ss:semconf}
We define a reduction relation on configurations, coupled with a structural congruence
 on processes and configurations.
Our reduction semantics defines a \emph{decoupled} treatment for reversing communication actions within a protocol.
Reduction is thus defined as $\red \subset \confs \times \confs$, whereas structural congruence is defined as $\scong\, \subset \procs^{2} \cup \confs^{2}$.  We require auxiliary definitions for \emph{contexts}, \emph{stores}, and \emph{type contexts}.

%\begin{definition}
\emph{Evaluation contexts} are configurations with one hole 
 `$\bullet$',  defined by:
$$\ctx{E}\bnfis \bullet \sbnfbar M\Par \ctx{E} \sbnfbar \news{n}\, \ctx{E}$$
\emph{General contexts} $\ctx{C}$ are processes or configurations with one hole~$\bullet$: they are obtained  by replacing one occurrence of $\inact$ (as a process or as a configuration) with $\bullet$.
%\end{definition}
%\noindent 
A congruence on processes and configurations is an equivalence  $\Re$ that is closed under general contexts: $P \,\Re\,  Q \Longrightarrow \myctx{C}{P}\,\Re\,  \myctx{C}{Q}$
and $M\Re N \Longrightarrow \myctx{C}{M}\,\Re\,  \myctx{C}{N}$.
We rely on a notion of structural congruence on processes and configurations, denoted $\equiv$ and defined in~\cite{DBLP:conf/ppdp/MezzinaP17}.
%that satisfies the axioms in Fig.~\ref{fig:str}. \modif{Most axioms are standard and/or similar to those for the $\pi$-calculus~\cite{DBLP:conf/concur/SangiorgiW01}; the exception is $\np{\key{\loc}{\er}}{\conf{}{\news{a}P}} \scong \news{a}\np{\key{\loc}{\er}}{\conf{}{P}}$, which allows a bound name to cross the boundaries of a running process, 
%thus relating processes and configurations.}
A relation $\Re$ on configurations is \emph{evaluation-closed} if it satisfies the   following rules:
\begin{mathpar}
 \inferrule*[left=(Ctx)]{M\,\Re\, N}{\myctx{E}{M}\,\Re\, \myctx{E}{N}} \and 
 \inferrule*[left=(Eqv)]{M \scong M' \and M' \,\Re\, N' \and N'\scong N}{M \,\Re\, N} \and 
\end{mathpar}

%\begin{figure}[t!]
%{%\small
%\[
%	\begin{array}{c}
%		A \Par \inact \scong A
%		\quad
%		A \Par B \scong B \Par A
%		\quad
%		A \Par (B \Par C) \scong (A \Par B) \Par C
%%		\\[1mm]
%%		\quad 
%		\\[1mm]
%		A \Par \news{n} B \scong \news{n}(A \Par B)
%		\ (n \notin \fn{P})
%				\quad
%		\news{n} \inact \scong \inact
%		\\[1mm]
%		\recp{X}{P} \scong P\subst{\recp{X}{P}}{\rvar{X}}
%%		\\[1mm]
%		\quad
%		A \scong B \textrm{ if } A \scong_\alpha B\\
%		\modif{\np{\key{\loc}{\er}}{\conf{\stack{C}}{\news{a}P}} \scong \news{a}\np{\key{\loc}{\er}}{\conf{\stack{C}}{P}} }
%		%\todo{check this}
%%		\qquad
%%		\dk{V \scong W \textrm{ if } V \scong_\alpha W
%%\quad \abs{x}{P} \scong \abs{x}{Q} \textrm{ if } P \scong Q} 
%%\quad
%%	\np{\key{k}{i}}{(P \Par Q)} \scong \np{\key{k}{i}}{P} \Par \np{\key{k}{i}}{Q}
%	\end{array}
%\]
%}
%\vspace{-4mm}
%\caption{Structural Congruence.}
%\label{fig:str}
%\end{figure}
%To enable reversible labeled choices, we define the following class of \textit{choice contexts}:
%
%\begin{definition}[Choice context]
%\textit{Choice contexts} are processes with one hole, denoted ``$\bullet$'', and defined by the following grammar:
%%\begin{align*}
%%& \ctx{K},\ctx{H} \bnfis \quad \bullet \sbnfbar 
%%\bsel{u}{\lbl_w}\ctx{K} + \freeze{\sum_{i\in I\setminus w}\bsel{u}{\lbl_i} P_i} \sbnfbar 
%%\bbra{u}{\lbl_w:\ctx{K} \,,\, \freeze{\lbl_i:P_i}}_{i \in I\setminus w}
%%\end{align*}
%\begin{align*}
%& \ctx{K},\ctx{H} \bnfis \quad \bullet \sbnfbar 
%\ctx{K} + \freeze{\sum_{i\in I}\bsel{u}{\lbl_i} P_i} \sbnfbar 
%\bbra{u}{\ctx{K} \,,\, \freeze{\lbl_i:P_i}}_{i \in I}
%\end{align*}
%\end{definition}

%\noindent
The state of monitored processes is formalized as follows:

\begin{definition} \label{d:store}
A store $\store$ maps variables to values. Given a store $\store$, a variable $x$, and a value $V$, 
the \emph{update} $\store\upd{x}{V}$ and the 
 \emph{reverse update} $\rup{\store}{x}$ are defined as:
%\cm{we have to understand better this thing of all bound variables are different }
\begin{align*}
\store\upd{x}{V} & = \begin{cases}
\store\cup \{(x,V)\} &\text{ if } x\not\in \mathtt{dom}(\store) \\ 
\text{ undefined }  & \text{otherwise}
\end{cases} 
\quad
\rup{\store}{x} & =  \begin{cases}
\store_1 &\text{ if } \store=\store_1\cup \{(x,V)\} \\ 
\store  & \text{otherwise}
\end{cases} 
\end{align*}
\end{definition}

\noindent Together with local types with history, the following notion of type context allows us to keep the current protocol state inside monitors: 
\begin{definition} 
\added{Let $k, k', \ldots$ denote fresh name identifiers.} We define 
\textit{type contexts} as (local) types with one hole, denoted ``$\bullet$'':
\begin{align*}
 \ctx{T},\ctx{S}   \bnfis  &  \bullet  \erase{\sbnfbar
 \q\btsel{\lbl_w:\ctx{T} \;;\; \lbl_i:S_i}_{i \in I\setminus w} \sbnfbar \q\btbra{\lbl_w:\ctx{T} \, , \, \lbl_i:S_i}_{i \in I\setminus w}}
 \\
  &\sbnfbar   \alpha.\ctx{T} \sbnfbar    k.\ctx{T} \sbnfbar (\loc,\loc_1,\loc_2).\ctx{T} 
\end{align*}
%\cm{They are no more types, because of $k$. Moreover we can compact $k$.T and $(k,k_1,k_2).T$ with $\tilde{k}$ but as to be an ordered list}
%\cm{Dire cosa sono $k$ and $\loc$}
\end{definition}
\added{\noindent Type contexts $k.\ctx{T}$ 
and $(\loc,\loc_1,\loc_2).\ctx{T}$ 
will be instrumental in formalizing reversibility of
name applications and thread spawning, respectively, which are not described by local types.}
This way, we will often have monitors of the form
$\monig{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past S}}{\mytilde{x}}{\store}$, where  
$\ctx{T}$ and $S$ describe past and future protocol steps for $\p$, respectively.



%%% ==== START QUEUE EQUIVALENCE
%\begin{definition}[Equivalence on message queues]
%%\cm{Not sure we need this, otherwise we have that $a \rightarrow b; c \rightarrow d = c \rightarrow d; a \rightarrow b$}
%%\jp{I have modified this.}
%%Let $m$ stand for either $V$ or $\lbl$. 
%We define the structural equivalence on queues, denoted $\equivq$, as follows:
%\begin{align*}
%h\cons \valueq{\p_1}{\q_1}{\anyv_1} \cons \valueq{\p_2}{\q_2}{\anyv_2}  \cons h'
%\equivq 
%\qquad \qquad \qquad
%\\
%%\vspace{5mm}
%\qquad \qquad \qquad
%h\cons \valueq{\p_2}{\q_2}{\anyv_2} \cons \valueq{\p_1}{\q_1}{\anyv_1} \cons h'
%\end{align*}
%whenever $\p_1 \neq \p_2 \land \q_1 \neq \q_2$.
%Equivalence $\equivq$ extends  to configurations as expected.
%\end{definition}
%%% ==== END QUEUE EQUIVALENCE

\added{Abstraction passing can implement a form of \emph{session delegation}, for 
received abstractions $\abs{x}{P}$ can contain 
 free session names (indexed by participant identities). The following definition  identifies those names:}

\begin{definition}
Let 
$h$ and $\p$ be a queue 
and a participant, respectively. 
Also, let  \\
$\{\valueq{\q_1}{\p}{\abs{x_1}{P_1}}, \ldots, \valueq{\q_k}{\p}{\abs{x_k}{P_k}} \}$ 
 denote the (possibly empty) set of messages in $h$ containing abstractions sent to $\p$.
We write 
$\names{\p, h}$ to denote the set of participant identities occurring in 
$P_1, \ldots, P_k$.
%$\sn{P_1} \cup \cdots \cup \sn{P_k}$.}
\end{definition}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{figure*}[t!]
{%\small
\begin{mathpar}
\inferrule*[left=\fwcolor{(Init)}]
{\parties{G}= \{\p_1,\cdots,\p_n\} \and 
\forall \gpart{p}_i\in \parties{G}. \, \tproj{G}{\gpart{p}_i} = T_{i}  } 
{ 
\!\!\!\!
\begin{array}{c}
\myloc{\loc_1}{\bout{a}{x_1:T_1}{P_{1}}} \Par 
\prod_{i \in \{2, \cdots, n\}}\myloc{\loc_i}{\binp{a}{x_i:T_i}{P_{i}}} 
\\
\fw
\\
\news{s} \left(\, 
\prod_{i \in\{1,\cdots,n\}} \np{\key{{\loc_{i}}}{\p_i}}{ \conf{\inact}{P_i\subst{\ep{s}{\p_i}}{x_i}}} \Par 
\moni{\ep{s}{\p_i}}{\past T_{i}}{x_i}{\upd{x_i}{a }}  \Par \codah{s}{\emp}{\emp}{}\right)\!\!\!\!
\end{array}
}
\and
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\inferrule*[left = \fwcolor{(Out)}]{ \p = \er \,\vee\, \p \in \names{\er, h_i} }{
\begin{array}{c}
\np{\key{\loc}{\er}}{ \conf{\stack{C}}{\bout{\ep{s}{\p}}{V}{P}}} \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past  \ltout{\q}{U}{S}}}{\mytilde x}{\store} \Par \codah{s}{h_i}{h_o}{}  
\\
\fw 
\\
\np{\key{\loc}{\er}}{\conf{\stack{C}}{P}} \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{ \ltoutp{\q}{U}{S}}}{\mytilde x}{\store} \Par 
\codah{s}{h_i}{h_o\cons \valueq{\p}{\q}{\myeval{V}{\sigma}}}{}
\end{array}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and 
%
\inferrule*[left = \fwcolor{(In)}]{
\p = \er \,\vee\, \p \in \names{\er, h_i}
}
{\begin{array}{c}
\np{\key{\loc}{\er}}{\conf{\stack{C}}{\binp{\ep{s}{\p}}{y}{P}}} \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past  \ltinp{\q}{U}{S}}}{\mytilde x}{\store} \Par \codah{s}{h_i}{\valueq{\q}{\p}{V}\cons h_o }{}
\\
\fw 
\\
\np{\key{\loc}{\er}}{\conf{\stack{C}}{P}} \Par \moni{\ep{s}{\p}}{ \myctxr{\ctx{T}}{\ltinpp{\q}{U}{S}}}{\mytilde x, y}{\store\upd{y}{V}} \Par 
\codah{s}{h_i\cons  \valueq{\q}{\p}{V}}{h_o }{} 
\end{array}
} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
\erase{
\inferrule*[left=\fwcolor{(Sel)}]
{\p = \er \,\vee\, \p \in \names{\er, h_i}
\and
w\in J \and J\subseteq I }
{ 
\begin{array}{c}
\np{\key{\loc}{\er}}{ \conf{\stack C}{\bsel{\ep{s}{\p}}{\lbl_i. P_i}_{i\in I}}}  \Par 
\moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past \ltsel{\q}{\lbl_j}{S_j}{j}{J}} }{\mytilde x}{\store} \Par \codah{s}{h_i}{h_o}{} \quad 
\\
\fw 
\\
\np{\key{\loc}{\er}}{ \conf{\stack C , \bsel{\ep{s}{\p}}{\lbl_i.P_i}_{i\in I\setminus w} }{P_w} }\Par 
\moni{\ep{s}{\p}}{ \myctxr{\ctx{T}}{ \ltselp{\q}{\lbl_j:S_j \, , \, \lbl_w:\past S_w}{j}{J\setminus w}} }{\mytilde x}{\store} 
\\
%\quad \qquad
\Par 
\codah{s}{h_i}{h_o\cons  \valueq{\p}{\q}{\lbl_w} }{} 
\end{array} 
 }
 }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
\erase{
\inferrule*[left=\fwcolor{(Bra)}]{\p = \er \,\vee\, \p \in \names{\er, h_i} 
\and w\in I \and I\subseteq J }
{
\begin{array}{c}
\np{\key{\loc}{\er}}{ \conf { \stack C}{\bbra{\ep{s}{\p}}{\lbl_i:P_i}_{i \in I} } } \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}
{\past \ltbra{\q}{\lbl_j}{S_j}{j}{J}} }{\mytilde x}{\store} \Par \codah{s}{h_i}{\valueq{\q}{\p}{\lbl_w}\cons h_o}{} 
\\
\fw 
\\
\np{\key{\loc}{\er}}{ \conf { \stack C , \bbra{\ep{s}{\p}}{\lbl_i:P_i}_{i \in I\setminus w}}{ P_w} } \Par 
\moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\ltbrap{\q}{\lbl_j:S_j\,,\, \lbl_w:\past S_w}{j}{J\setminus w}} }{\mytilde x}{\store}
\\
%\quad  \qquad 
\Par \codah{s}{h_i\cons  \valueq{\q}{\p}{\lbl_w}}{h_o}{}
\end{array}
 }
 }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
%
\inferrule*[left=\fwcolor{(Beta)}]{\myeval{V}{\sigma} =\abs{x}{P} }
{
\begin{array}{l}
\np{\key{\loc}{\p}}{\conf{\stack{C}}{(\appl{V}{w})}} \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past S}}{\mytilde x}{\store} 
~\fw~ 
\\
\news{k}\, \left( {\np{\key{\loc}{\p}}{\conf{\ctx{\stack {C}}}{P\subst{\myeval{w}{\sigma}}{x}}}}  \Par \mem{k}{(\appl{V}{w})}{\loc} \Par\moni{\ep{s}{\p}}{\myctxr{\ctx T}{ k. \past S}}{\mytilde x}{\store} \right)
\end{array}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
%
\inferrule[\fwcolor{(Spawn)}]{ }
{
\begin{array}{c}
\np{\key{\loc}{\p}}{\conf{\stack{C}}{P \Par Q}} \Par \moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past S}}{\mytilde x}{\store} 
%\\
~\fw~ 
\\
\news{\loc_1,\loc_2}\, \left( \np{\key{\loc}{\p}}{\conf{\stack{C}}{\inact}}  
\Par \np{\key{{\loc_1}}{\p}}{\conf{\inact}{P}}
\Par \np{\key{{\loc_2}}{\p}}{\conf{\inact}{Q}} 
\Par \moni{\ep{s}{\p}}{\myctxr{\ctx T}{ (\loc,\loc_1,\loc_2). \past S}}{\mytilde x}{\store} \right)
\end{array}
}

\end{mathpar}
}
\vspace{-10mm}
\caption{Decoupled semantics for configurations: Forward reduction ($\fw$).}
\label{fig:fw}
\vspace{-6mm}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}[h!]
{%\small
\begin{mathpar}
\inferrule*[left=\bkcolor{(RInit)}]
{\parties{G}= \{\p_1,\cdots,\p_n\} \and 
\forall \gpart{p}_i\in \parties{G}. \, \tproj{G}{\gpart{p}_i} = T_{i} \and Q_i = P_{i}\subst{\ep{s}{\p_i}}{x_i} } 
{ 
\!\!\!\!
\begin{array}{c}
\news{s} \left(\, 
\prod_{i \in\{1,\cdots,n\}} \np{\key{{\loc_i}}{\p_i}}{ \conf{\inact}{Q_i}} \Par 
\hmoni{\ep{s}{\p_i}}{\past T_{i}}{x_i}{\upd{x_i}{a }}  \Par \codah{s}{\emp}{\emp}{}\right)
\\
~\bk~
\\
\myloc{\loc_1}{\bout{a}{x_1:T_1}{P_{1}}} \Par 
\prod_{i \in \{2, \cdots, n\}} \myloc{\loc_i}{\binp{a}{x_i:T_i}{P_i}}
\end{array}
\!\!\!\!
}
\and
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\inferrule*[left=\bkcolor{(RollS)}]{ }{
\begin{array}{c}
\hmoni{\ep{s}{\p}}{ \myctxr{\ctx T}{\ltinpp{\q}{U}{T}}}{\mytilde x}{\store_1} \Par 
\hmoni{\ep{s}{\q}}{ \myctxr{\ctx S}{\ltoutp{\p}{U}{S}}}{\mytilde y}{\store_2} \Par 
%\codah{s}{h_i}{h_o}{\restrict{\mytilde{\gpart{r}}}}
\codah{s}{h_i}{h_o}
%\quad 
\\
\bk 
\\
\monir{\ep{s}{\p}}{ \myctxr{\ctx T}{\ltinpp{\q}{U}{T}}}{\mytilde x}{\store_1} \Par 
\monir{\ep{s}{\q}}{\myctxr{\ctx S}{\ltoutp{\p}{U}{S}}}{\mytilde y}{\store_2} \Par 
%\codah{s}{h_i}{h_o}{\restrict{\mytilde{\gpart{r}},\p,\q}}
\codah{s}{h_i}{h_o}
\end{array}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and 
%
\erase{
\inferrule*[left=\bkcolor{(RollC)}]{ }{
\begin{array}{c}
\hmoni{\ep{s}{\p}}{\myctxr{\ctx T}{\ltbrap{\q}{\lbl_z:\past S_z\,,\,\lbl_w:S_w}{z}{J\setminus w}}}{\mytilde x}{\store_1}  \Par 
\\
\hmoni{\ep{s}{\q}}{\myctxr{\ctx S}{\ltselp{\p}{\lbl_z:\past S_z \, , \, \lbl_w: S_w}{z}{J\setminus w}}}{\mytilde y}{\store_2}  \Par 
%\codah{s}{h_i}{h_o}{\restrict{\mytilde{\gpart{r}}}}
\codah{s}{h_i}{h_o}
\\
\bk 
\\
\monir{\ep{s}{\p}}{ \myctxr{\ctx T}{\ltbrap{\q}{\lbl_z:\past S_z\,,\,\lbl_w:S_w}{z}{J\setminus w}}}{\mytilde x}{\store_1}  \Par 
\\
\monir{\ep{s}{\q}}{\myctxr{\ctx S}{\ltselp{\p}{\lbl_z:\past S_z \, , \, \lbl_w: S_w}{z}{J\setminus w}}}{\mytilde y}{\store_2}  \Par 
%\codah{s}{h_1}{h_2}{\restrict{\mytilde{\gpart{r}},\p,\q}}
\codah{s}{h_i}{h_o}
\end{array}
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
%
\inferrule[\bkcolor{(ROut)}]{ \p = \er \,\vee\, \p \in \names{\er, h_i}}
{
\!\!\!\!
\begin{array}{l}
\np{\key{\loc}{\er}}{\conf{\stack C}{P}} \Par \monir{\ep{s}{\p}}{ \myctxr{\ctx T}{\ltoutp{\q}{U}{S}} }{\mytilde x}{\store}
\Par 
%\codah{s}{h_i}{(\p,\q,V)\cons h_o}{\restrict{\p,\mytilde{\gpart{r}}}}
\codah{s}{h_i}{(\p,\q,V)\cons h_o}
%\\
~\bk~
\\
\np{\key{\loc}{\er}}{\conf{\stack C }{\bout{\ep{s}{\p}}{V}{P}}} \Par 
\hmoni{\ep{s}{\p}}{ \myctxr{\ctx T}{\past\ltout{\q}{U}{S}} }{\mytilde x}{\store}
 \Par %\codah{s}{h_i}{h_o}{\restrict{\mytilde{\gpart{r}}}}
 \codah{s}{h_i}{h_o}
\end{array}
\!\!\!\!
 }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
%
\inferrule*[left=\bkcolor{(RIn)}]{ 
\p = \er \,\vee\, \p \in \names{\er, h_i}
}
{
\begin{array}{c}
\np{\key{\loc}{\er}}{\conf{\stack C}{P}} \Par 
\monir{\ep{s}{\p}}{ \myctxr{\ctx T} {\ltinpp{\q}{U}{S}} }{\mytilde x,y}{\store} \Par 
%\codah{s}{h_i\cons(\q,\p,V)}{h_o}{\restrict{\p,\mytilde{\gpart{r}}}}
\codah{s}{h_i\cons(\q,\p,V)}{h_o}
\\
\quad \bk
\\
\np{\key{\loc}{\er}}{\conf{\stack C} { \binp{\ep{s}{\p}}{y}{P}} } \Par 
\hmoni{\ep{s}{\p}}{ \myctxr{\ctx T}{\past\ltinp{\q}{U}{S}}}{\mytilde x}{\rup{\store}{y}}\Par %\codah{s}{h_i}{(\q,\p,V)\cons h_o}{\restrict{\mytilde{\gpart{r}}}}
\codah{s}{h_i}{(\q,\p,V)\cons h_o}
\end{array}
 }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
\erase{
\inferrule*[left=\bkcolor{(RBra)}]
{ \p = \er \,\vee\, \p \in \names{\er, h_i} \and w \in I \and I\subseteq J} 
{
\begin{array}{c}
\np{\key{\loc}{\er}}{\conf{\stack C,\bbra{\ep{s}{\p}}{\lbl_i:P_i }_{i \in I\setminus\set{w}}}{P}
} \Par 
\monir{\ep{s}{\p}}{\myctxr{\ctx T}{\ltbrap{\q}{\lbl_j:S_j\,,\, \lbl_w:\past S_w}{j}{J\setminus w}} }{\mytilde x}{\store}
\\
\Par 
%\codah{s}{h_i\cons  \valueq{\q}{\p}{\lbl_w}}{h_o}{\restrict{\p, \mytilde{\gpart{r}}}}
\codah{s}{h_i\cons  \valueq{\q}{\p}{\lbl_w}}{h_o}
\\
\quad \bk 
\\%[1mm]
\np{\key{\loc}{\er}}{ \conf{\stack C}{\bbra{\ep{s}{\p}}{\lbl_i:P_i, \lbl_w : P }_{i \in I\setminus\set{w}}}} \Par 
\hmoni{\ep{s}{\p}}{\myctxr{\ctx T}{\past\ltbra{\q}{\lbl_j}{S_j}{j}{J}} }{\mytilde x}{\store} 
\Par 
%\codah{s}{h_i}{\valueq{\q}{\p}{\lbl_w}\cons h_o}{\restrict{\mytilde{\gpart{r}}}}
\\
\codah{s}{h_i}{\valueq{\q}{\p}{\lbl_w}\cons h_o}
\end{array}
 }}
\and 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\erase{
\inferrule*[left=\bkcolor{(RSel)}]
{ \p = \er \,\vee\, \p \in \names{\er, h_i} \and w \in I \and I\subseteq J} 
{
\begin{array}{c}
\np{{\key{\loc}{\er}}}{ \conf{\stack C,\bsel{\ep{s}{\p}}{\lbl_i. P_i}_{i\in I} }{P}} \Par 
\monir{\ep{s}{\p}}{ \myctxr{\ctx T}{ \ltselp{\q}{\lbl_j:S_j \, , \, \lbl_w:\past S_w}{j}{J\setminus w} } }{\mytilde x}{\store}
\Par 
%\codah{s}{h_i}{\valueq{\p}{\q}{\lbl_w}\cons h_o}{\restrict{\p,\mytilde{\gpart{r}}}}
\codah{s}{h_i}{\valueq{\p}{\q}{\lbl_w}\cons h_o}
\\
\quad \bk 
\\
\np{{\key{\loc}{\er}}}{ \conf{\stack C}{ \bsel{\ep{s}{\p}}{\lbl_w. P} + \bsel{\ep{s}{\p}}{\lbl_i. P_i}_{i\in I} } } \Par 
\hmoni{\ep{s}{\p}}{ \myctxr{\ctx T}{ \past \ltsel{\q}{\lbl_j}{S_j}{j}{J} } }{\mytilde x}{\store} \Par 
%\codah{s}{h_i}{h_o}{\restrict{\mytilde{\gpart{r}}}}
\codah{s}{h_i}{h_o}
\end{array}
}
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\and
%
\inferrule*[left=\bkcolor{(RBeta)}]{ }
{
\begin{array}{l}
\news{k}\,\left( {\np{\key{\loc}{\p}}{\conf{\stack{C}}{Q} }}  \Par \mem{k}{(\appl{V}{w})}{\loc} 
\Par\moni{\ep{s}{\p}}{\myctxr{\ctx T}{ k. \past S}}{\mytilde x}{\store}
\right)
%\\
~\bk~ 
%\\
\np{\key{\loc}{\p}}{\conf{\stack{C}}{(\appl{V}{w})}} \Par 
\moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past S}}{\mytilde x}{\store} 
\end{array} 
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \and
\inferrule[\bkcolor{(RSpawn)}]{ }
{
\begin{array}{c}
\news{\loc_1,\loc_2}\, \left( {\np{\key{\loc}{\p}}{\conf{\stack{C}}{\inact}}}  
\Par \np{\key{{\loc_1}}{\p}}{\conf{\inact}{P}}
\Par \np{\key{{\loc_2}}{\p}}{\conf{\inact}{Q}} 
\Par \moni{\ep{s}{\p}}{\myctxr{\ctx T}{ (\loc,\loc_1,\loc_2). \past S}}{\mytilde x}{\store} \right)
%\\
~\bk~
\\
\np{\key{\loc}{\p}}{\conf{\stack{C}}{P \Par Q}} \Par 
\moni{\ep{s}{\p}}{\myctxr{\ctx{T}}{\past S}}{\mytilde x}{\store}  
\end{array}
}

\end{mathpar}
}
\vspace{-8mm}
\caption{Decoupled semantics for configurations: Backwards reduction ($\bk$).}
\label{fig:bk}
%\vspace{-3mm}
\end{figure*}

%\noindent 
The reduction relation $\red$ is defined as the union of %two relations: 
the forward and backward
reduction relations, denoted $\fw$  and $\bk$, respectively. That is, $\red\, = \fw \cup \bk$. Relations $\fw$ and 
$\bk$ are the smallest evaluation-closed relations satisfying the rules in Figs.~\ref{fig:fw} and~\ref{fig:bk}. We indicate with $ \trans{\red} $, $ \fws $, and $ \bks $  the reflexive and transitive closure of $\red$, $\fw$ and $\bk$, respectively.
%We write $M \red^k M'$ to denote a sequence of $k \geq 0$ reduction steps (if $k=0$ then $M = M'$)
We first discuss the forward reduction rules (Fig.~\ref{fig:fw}): %, omitting empty tags $\normark$:
% given in \ref{fig:fw} and \ref{fig:bk}.

\begin{enumerate}[$\fwcolor{\blacktriangleright}$]
\item Rule \fwcolor{\textsc{(Init)}} initiates a choreography  $G$ with $n$ participants.
Given the composition of one service request and $n-1$ service accepts (all along $a$, available in different locations~$\loc_i$),
this rule sets up the run-time elements:
running processes and  monitors---one for each participant, with empty tag (omitted)---and the empty session queue. 
A unique session identifier  ($s$ in the rule) is also created.
The processes are inserted in 
their respective running structures, and instantiated with an appropriate session name.
Similarly, the local types for each participant are inserted in their respective monitor, with the cursor $\past$ at the beginning.

\item Rule \fwcolor{\textsc{(Out)}} starts the output of value $V$ from $\p$ to $\q$. Given an output-prefixed process as running process,
and a monitor with a local type supporting an output action, reduction adds the message $\valueq{\p}{\q}{\myeval{V}{\sigma}}$ to the output part of the session queue (where $\sigma$ is the current store). Also, the cursor within the local type is moved accordingly.
In this rule (but also in several other rules), premise $\p = \er \,\vee\, \p \in \names{\er, h_i}$ allows performing actions on names previously received via abstraction passing.

\item Rule \fwcolor{\textsc{(In)}} allows a participant $\p$ to receive a value $V$ from $\q$: it 
simply takes the first element of the output part of the queue and places it in the input part.
The cursor of the local type and state in the  monitor for $\p$ are updated accordingly.

 
\item 
\erase{Rule \fwcolor{\textsc{(Sel)}} is the forward rule for labeled selection, which in our case entails a non-deterministic choice between 
pairwise different labels indexed by $I$. %This is how our construct is more general than usual selection constructs.
We require that $I$ is contained in $J$, i.e., the set that indexes the choice according to the choreography. 
After reduction, the selected label ($\lbl_w$ in the rule) is added to the output part of the queue, and the continuation $P_w$ is kept in the running process;
to support reversibility,
alternatives different from $\lbl_w$ are stored in the stack $\stack{C}$ with their continuations.
The cursor is also appropriately updated in the  monitor.}

\item 
\erase{Rule~\fwcolor{\textsc{(Bra)}} is similar to Rule \fwcolor{\textsc{(Sel)}}: it takes a message containing a label $\lbl_w$ as the first element in the output part of the queue, and places it into the input part. This entails a selection between the options indexed by $I$; the continuation $P_w$ is kept in the running process, and all those options different from $\lbl_w$ are kept in the stack. Also, the local type in the monitor is updated accordingly.
}
\item Rule~\fwcolor{\textsc{(Beta)}} handles name applications. Reduction  creates a fresh identifier ($k$ in the rule) for the running function, which keeps (i) the structure of the process prior to application, and (ii) the identifier of the running process that ``invokes'' the application. Notice that $k$ is recorded also in the monitor: this is necessary to undo applications in the proper order. To determine the actual abstraction and the name applied, we use   $\store$.

\item Rule~\fwcolor{\textsc{(Spawn)}} handles parallel composition. Location $\loc$ is ``split'' into running processes with fresh identifiers ($\loc_1, \loc_2$ in the rule). This split is recorded in the   monitor.
\end{enumerate}


%\todo{ADD SIMPLE EXAMPLE (NOW IN APPENDIX) OF CHOICE CONTEXTS (FWD ONLY).}

\noindent
Now we comment on the backward rules (Fig.~\ref{fig:bk}) which, in most cases, change the monitor tags from $\normark$ into $\bkcolor{\rmark}$:

\begin{enumerate}[$\bkcolor{\blacktriangleleft}$]
\item Rule \bkcolor{\textsc{(RInit)}} undoes session establishment. It requires that local types for every participant are at the beginning of the protocol, and empty session queue and process stacks. Run-time elements are discarded; located service accept/requests are reinstated.

\item Rule~\bkcolor{\textsc{(RollS)}} starts to undo an input-output synchronization between $\p$ and $\q$. 
Enabled when there are complementary session types in the two monitors, this rule changes the monitor tags  from $\normark$ to $\bkcolor{\rmark}$. %, and marks  the queue with $\p$ and $\q$, to indicate that messages in the queue could now be moved between its input and output parts. 
This way, the undoing of input and output actions occurs in a decoupled way. 
%\item 
Rule \bkcolor{\textsc{(RollC)}} is the analog of~\bkcolor{\textsc{(RollS)}} but for synchronizations originated in labeled choices.

\item Rule \bkcolor{\textsc{(ROut)}} undoes an output. This is only possible for a  monitor tagged with $\bkcolor{\rmark}$, exploiting the first message in the input queue. After reduction, the process prefix is reinstated, the cursor is adjusted, the message is removed from the queue, 
the   monitor is tagged again with $\normark$.
%, and the identity of the involved participant ($\p$ in the rule) is removed from the  queue
%\item 
Rule \bkcolor{\textsc{(RIn)}} is the analog of Rule \bkcolor{\textsc{(ROut)}}. In this case, we also need to update the state of store $\store$. 
%\jp{Actually, it seems better to explain \textsc{(RollIn)} first and then \textsc{(RollOut)}.}

\item 
\erase{Rule \bkcolor{\textsc{(RBra)}} undoes the input part of a labeled choice: the choice context is reinstated; the cursor is moved; the last message in the input part of the queue is moved to the output part. 
%; the identity of the participant ($\p$ in the rule) is removed from the queue; and the monitor is tagged again with $\normark$.
\item 
Rule \bkcolor{\textsc{(RSel)}} is the analog of~\bkcolor{\textsc{(RBra)}}, but for the output part of the labeled choice. The non-deterministic   selection is reinstated.}

\item Rule \bkcolor{\textsc{(RBeta)}} undoes $\beta$-reduction, reinstating the application. The running function disappears, using the information in the 
  monitor ($k$ in the rule).
Rule~\bkcolor{\textsc{(RSpawn)}} undoes the spawn of a parallel thread, using the identifiers in the  monitor. 
%\jp{This rule will depend on what we decide for parallel inside processes, and session initiation.}
\end{enumerate}


\section{Our Haskell Implementation}

\section{Future Work}
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
 \bibliographystyle{abbrv}
 \bibliography{session,biblio}
%
\end{document}
